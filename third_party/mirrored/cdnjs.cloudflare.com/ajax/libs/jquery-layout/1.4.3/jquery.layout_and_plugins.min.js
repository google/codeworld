/*

 jquery.layout 1.4.3
 $Date: 2014-08-30 08:00:00 (Sat, 30 Aug 2014) $
 $Rev: 1.0403 $

 Copyright (c) 2014 Kevin Dalman (http://jquery-dev.com)
 Based on work by Fabrizio Balliano (http://www.fabrizioballiano.net)

 Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.

 SEE: http://layout.jquery-dev.com/LICENSE.txt

 Changelog: http://layout.jquery-dev.com/changelog.cfm

 Docs: http://layout.jquery-dev.com/documentation.html
 Tips: http://layout.jquery-dev.com/tips.html
 Help: http://groups.google.com/group/jquery-ui-layout
 jquery.layout.buttons 1.0
 $Date: 2011-07-16 08:00:00 (Sat, 16 July 2011) $

 Copyright (c) 2011
   Kevin Dalman (http://allpro.net)

 Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.

 @dependancies: UI Layout 1.3.0.rc30.1 or higher

 @support: http://groups.google.com/group/jquery-ui-layout

 Docs: [ to come ]
 Tips: [ to come ]
	jquery.layout.slideOffscreen-1.1.js
*/
(function (a) {
  const f = Math.min,
    e = Math.max,
    h = Math.floor,
    c = function (b) {
      return "string" === a.type(b);
    },
    m = function (b, e) {
      if (a.isArray(e)) {
        for (let A = 0, f = e.length; A < f; A++) {
          let h = e[A];
          try {
            c(h) && (h = eval(h)), a.isFunction(h) && h(b);
          } catch (n) {}
        }
      }
    };
  a.layout = {
    version: "1.4.3",
    revision: 1.0403,
    browser: {},
    effects: {
      slide: {
        all: { duration: "fast" },
        north: { direction: "up" },
        south: { direction: "down" },
        east: { direction: "right" },
        west: { direction: "left" },
      },
      drop: {
        all: { duration: "slow" },
        north: { direction: "up" },
        south: { direction: "down" },
        east: { direction: "right" },
        west: { direction: "left" },
      },
      scale: { all: { duration: "fast" } },
      blind: {},
      clip: {},
      explode: {},
      fade: {},
      fold: {},
      puff: {},
      size: { all: { easing: "swing" } },
    },
    config: {
      optionRootKeys: "effects panes north south west east center".split(" "),
      allPanes: ["north", "south", "west", "east", "center"],
      borderPanes: ["north", "south", "west", "east"],
      oppositeEdge: {
        north: "south",
        south: "north",
        east: "west",
        west: "east",
      },
      offscreenCSS: { left: "-99999px", right: "auto" },
      offscreenReset: "offscreenReset",
      hidden: { visibility: "hidden" },
      visible: { visibility: "visible" },
      resizers: {
        cssReq: {
          position: "absolute",
          padding: 0,
          margin: 0,
          fontSize: "1px",
          textAlign: "left",
          overflow: "hidden",
        },
        cssDemo: { background: "#DDD", border: "none" },
      },
      togglers: {
        cssReq: {
          position: "absolute",
          display: "block",
          padding: 0,
          margin: 0,
          overflow: "hidden",
          textAlign: "center",
          fontSize: "1px",
          cursor: "pointer",
          zIndex: 1,
        },
        cssDemo: { background: "#AAA" },
      },
      content: {
        cssReq: { position: "relative" },
        cssDemo: { overflow: "auto", padding: "10px" },
        cssDemoPane: { overflow: "hidden", padding: 0 },
      },
      panes: {
        cssReq: { position: "absolute", margin: 0 },
        cssDemo: {
          padding: "10px",
          background: "#FFF",
          border: "1px solid #BBB",
          overflow: "auto",
        },
      },
      north: {
        side: "top",
        sizeType: "Height",
        dir: "horz",
        cssReq: { top: 0, bottom: "auto", left: 0, right: 0, width: "auto" },
      },
      south: {
        side: "bottom",
        sizeType: "Height",
        dir: "horz",
        cssReq: { top: "auto", bottom: 0, left: 0, right: 0, width: "auto" },
      },
      east: {
        side: "right",
        sizeType: "Width",
        dir: "vert",
        cssReq: {
          left: "auto",
          right: 0,
          top: "auto",
          bottom: "auto",
          height: "auto",
        },
      },
      west: {
        side: "left",
        sizeType: "Width",
        dir: "vert",
        cssReq: {
          left: 0,
          right: "auto",
          top: "auto",
          bottom: "auto",
          height: "auto",
        },
      },
      center: {
        dir: "center",
        cssReq: {
          left: "auto",
          right: "auto",
          top: "auto",
          bottom: "auto",
          height: "auto",
          width: "auto",
        },
      },
    },
    callbacks: {},
    getParentPaneElem: function (b) {
      b = a(b);
      if ((b = b.data("layout") || b.data("parentLayout"))) {
        b = b.container;
        if (b.data("layoutPane")) return b;
        b = b.closest(`.${a.layout.defaults.panes.paneClass}`);
        if (b.data("layoutPane")) return b;
      }
      return null;
    },
    getParentPaneInstance: function (b) {
      return (b = a.layout.getParentPaneElem(b)) ? b.data("layoutPane") : null;
    },
    getParentLayoutInstance: function (b) {
      return (b = a.layout.getParentPaneElem(b))
        ? b.data("parentLayout")
        : null;
    },
    getEventObject: function (a) {
      return "object" === typeof a && a.stopPropagation ? a : null;
    },
    parsePaneName: function (b) {
      const e = a.layout.getEventObject(b);
      e && (e.stopPropagation(), (b = a(this).data("layoutEdge")));
      b &&
        !/^(west|east|north|south|center)$/.test(b) &&
        (a.layout.msg(`LAYOUT ERROR - Invalid pane-name: "${b}"`),
        (b = "error"));
      return b;
    },
    plugins: {
      draggable: Boolean(a.fn.draggable),
      effects: {
        core: Boolean(a.effects),
        slide:
          a.effects &&
          (a.effects.slide || (a.effects.effect && a.effects.effect.slide)),
      },
    },
    onCreate: [],
    onLoad: [],
    onReady: [],
    onDestroy: [],
    onUnload: [],
    afterOpen: [],
    afterClose: [],
    scrollbarWidth: function () {
      return window.scrollbarWidth || a.layout.getScrollbarSize("width");
    },
    scrollbarHeight: function () {
      return window.scrollbarHeight || a.layout.getScrollbarSize("height");
    },
    getScrollbarSize: function (b) {
      const e = a(
          '<div style="position: absolute; top: -10000px; left: -10000px; width: 100px; height: 100px; border: 0; overflow: scroll;"></div>'
        ).appendTo("body"),
        c = {
          width: e.outerWidth - e[0].clientWidth,
          height: 100 - e[0].clientHeight,
        };
      e.remove();
      window.scrollbarWidth = c.width;
      window.scrollbarHeight = c.height;
      return b.match(/^(width|height)$/) ? c[b] : c;
    },
    disableTextSelection: function () {
      const b = a(document);
      a.fn.disableSelection &&
        (b.data("textSelectionInitialized") ||
          b
            .on("mouseup", a.layout.enableTextSelection)
            .data("textSelectionInitialized", !0),
        b.data("textSelectionDisabled") ||
          b.disableSelection().data("textSelectionDisabled", !0));
    },
    enableTextSelection: function () {
      const b = a(document);
      a.fn.enableSelection &&
        b.data("textSelectionDisabled") &&
        b.enableSelection().data("textSelectionDisabled", !1);
    },
    showInvisibly: function (a, e) {
      if (a && a.length && (e || "none" === a.css("display"))) {
        var c = a[0].style,
          c = { display: c.display || "", visibility: c.visibility || "" };
        a.css({ display: "block", visibility: "hidden" });
        return c;
      }
      return {};
    },
    getElementDimensions: function (b, c) {
      let f = { css: {}, inset: {} },
        h = f.css,
        m = { bottom: 0 },
        n = a.layout.cssNum,
        H = Math.round,
        w = b.offset(),
        I,
        N,
        Q;
      f.offsetLeft = w.left;
      f.offsetTop = w.top;
      c || (c = {});
      a.each(["Left", "Right", "Top", "Bottom"], (e, n) => {
        I = h[`border${n}`] = a.layout.borderWidth(b, n);
        N = h[`padding${n}`] = a.layout.cssNum(b, `padding${n}`);
        Q = n.toLowerCase();
        f.inset[Q] = 0 <= c[Q] ? c[Q] : N;
        m[Q] = f.inset[Q] + I;
      });
      h.width = H(b.width());
      h.height = H(b.height());
      h.top = n(b, "top", !0);
      h.bottom = n(b, "bottom", !0);
      h.left = n(b, "left", !0);
      h.right = n(b, "right", !0);
      f.outerWidth = H(b.outerWidth());
      f.outerHeight = H(b.outerHeight());
      f.innerWidth = e(0, f.outerWidth - m.left - m.right);
      f.innerHeight = e(0, f.outerHeight - m.top - m.bottom);
      f.layoutWidth = H(b.innerWidth());
      f.layoutHeight = H(b.innerHeight());
      return f;
    },
    getElementStyles: function (a, e) {
      let c = {},
        f = a[0].style,
        h = e.split(","),
        n = ["Top", "Bottom", "Left", "Right"],
        m = ["Color", "Style", "Width"],
        w,
        I,
        N,
        Q,
        D,
        t;
      for (Q = 0; Q < h.length; Q++) {
        if (((w = h[Q]), w.match(/(border|padding|margin)$/))) {
          for (D = 0; 4 > D; D++) {
            if (((I = n[D]), "border" === w)) {
              for (t = 0; 3 > t; t++) (N = m[t]), (c[w + I + N] = f[w + I + N]);
            } else c[w + I] = f[w + I];
          }
        } else c[w] = f[w];
      }
      return c;
    },
    cssWidth: function (b, c) {
      if (0 >= c) return 0;
      var f = a.layout.browser,
        f = f.boxModel
          ? f.boxSizing
            ? b.css("boxSizing")
            : "content-box"
          : "border-box",
        h = a.layout.borderWidth,
        m = a.layout.cssNum,
        n = c;
      "border-box" !== f && (n -= h(b, "Left") + h(b, "Right"));
      "content-box" === f && (n -= m(b, "paddingLeft") + m(b, "paddingRight"));
      return e(0, n);
    },
    cssHeight: function (b, c) {
      if (0 >= c) return 0;
      var f = a.layout.browser,
        f = f.boxModel
          ? f.boxSizing
            ? b.css("boxSizing")
            : "content-box"
          : "border-box",
        h = a.layout.borderWidth,
        m = a.layout.cssNum,
        n = c;
      "border-box" !== f && (n -= h(b, "Top") + h(b, "Bottom"));
      "content-box" === f && (n -= m(b, "paddingTop") + m(b, "paddingBottom"));
      return e(0, n);
    },
    cssNum: function (b, e, c) {
      b.jquery || (b = a(b));
      const f = a.layout.showInvisibly(b);
      e = a.css(b[0], e, !0);
      c = c && "auto" == e ? e : Math.round(parseFloat(e) || 0);
      b.css(f);
      return c;
    },
    borderWidth: function (b, e) {
      b.jquery && (b = b[0]);
      const c = `border${e.substr(0, 1).toUpperCase()}${e.substr(1)}`;
      return "none" === a.css(b, `${c}Style`, !0)
        ? 0
        : Math.round(parseFloat(a.css(b, `${c}Width`, !0)) || 0);
    },
    isMouseOverElem: function (b, e) {
      var c = a(e || this),
        f = c.offset(),
        h = f.top,
        f = f.left,
        n = f + c.outerWidth(),
        c = h + c.outerHeight(),
        m = b.pageX,
        w = b.pageY;
      return (
        (a.layout.browser.msie && 0 > m && 0 > w) ||
        (m >= f && m <= n && w >= h && w <= c)
      );
    },
    msg: function (b, e, c, f) {
      a.isPlainObject(b) && window.debugData
        ? ("string" === typeof e
            ? ((f = c), (c = e))
            : "object" === typeof c && ((f = c), (c = null)),
          (c = c || "log( <object> )"),
          (f = a.extend({ sort: !1, returnHTML: !1, display: !1 }, f)),
          !0 === e || f.display
            ? debugData(b, c, f)
            : window.console && console.log(debugData(b, c, f)))
        : e
        ? alert(b)
        : window.console
        ? console.log(b)
        : ((e = a("#layoutLogger")),
          e.length ||
            ((e = a(
              `<div id="layoutLogger" style="position: ${
                a.support.fixedPosition ? "fixed" : "absolute"
              }; top: 5px; z-index: 999999; max-width: 25%; overflow: hidden; border: 1px solid #000; border-radius: 5px; background: #FBFBFB; box-shadow: 0 2px 10px rgba(0,0,0,0.3);"><div style="font-size: 13px; font-weight: bold; padding: 5px 10px; background: #F6F6F6; border-radius: 5px 5px 0 0; cursor: move;"><span style="float: right; padding-left: 7px; cursor: pointer;" title="Remove Console" onclick="$(this).closest('#layoutLogger').remove()">X</span>Layout console.log</div><ul style="font-size: 13px; font-weight: none; list-style: none; margin: 0; padding: 0 0 2px;"></ul></div>`
            ).appendTo("body")),
            e.css("left", a(window).width() - e.outerWidth() - 5),
            a.ui.draggable && e.draggable({ handle: ":first-child" })),
          e
            .children("ul")
            .append(
              `<li style="padding: 4px 10px; margin: 0; border-top: 1px solid #CCC;">${b
                .replace(/\</g, "&lt;")
                .replace(/\>/g, "&gt;")}</li>`
            ));
    },
  };
  (function () {
    var b = navigator.userAgent.toLowerCase(),
      e =
        /(chrome)[ \/]([\w.]+)/.exec(b) ||
        /(webkit)[ \/]([\w.]+)/.exec(b) ||
        /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(b) ||
        /(msie) ([\w.]+)/.exec(b) ||
        (0 > b.indexOf("compatible") &&
          /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(b)) ||
        [],
      b = e[1] || "",
      e = e[2] || 0,
      c = "msie" === b,
      f = document.compatMode,
      h = a.support,
      n = void 0 !== h.boxSizing ? h.boxSizing : h.boxSizingReliable,
      m = !c || !f || "CSS1Compat" === f || h.boxModel || !1,
      w = (a.layout.browser = {
        version: e,
        safari: "webkit" === b,
        webkit: "chrome" === b,
        msie: c,
        isIE6: c && 6 == e,
        boxModel: m,
        boxSizing: !("function" === typeof n ? !n() : !n),
      });
    b && (w[b] = !0);
    m ||
      f ||
      a(() => {
        w.boxModel = h.boxModel;
      });
  })();
  a.layout.defaults = {
    name: "",
    containerClass: "ui-layout-container",
    inset: null,
    scrollToBookmarkOnLoad: !0,
    resizeWithWindow: !0,
    resizeWithWindowDelay: 200,
    resizeWithWindowMaxDelay: 0,
    maskPanesEarly: !1,
    onresizeall_start: null,
    onresizeall_end: null,
    onload_start: null,
    onload_end: null,
    onunload_start: null,
    onunload_end: null,
    initPanes: !0,
    showErrorMessages: !0,
    showDebugMessages: !1,
    zIndex: null,
    zIndexes: {
      pane_normal: 0,
      content_mask: 1,
      resizer_normal: 2,
      pane_sliding: 100,
      pane_animate: 1e3,
      resizer_drag: 1e4,
    },
    errors: {
      pane: "pane",
      selector: "selector",
      addButtonError: "Error Adding Button\nInvalid ",
      containerMissing:
        "UI Layout Initialization Error\nThe specified layout-container does not exist.",
      centerPaneMissing:
        "UI Layout Initialization Error\nThe center-pane element does not exist.\nThe center-pane is a required element.",
      noContainerHeight:
        "UI Layout Initialization Warning\nThe layout-container \"CONTAINER\" has no height.\nTherefore the layout is 0-height and hence 'invisible'!",
      callbackError:
        "UI Layout Callback Error\nThe EVENT callback is not a valid function.",
    },
    panes: {
      applyDemoStyles: !1,
      closable: !0,
      resizable: !0,
      slidable: !0,
      initClosed: !1,
      initHidden: !1,
      contentSelector: ".ui-layout-content",
      contentIgnoreSelector: ".ui-layout-ignore",
      findNestedContent: !1,
      paneClass: "ui-layout-pane",
      resizerClass: "ui-layout-resizer",
      togglerClass: "ui-layout-toggler",
      buttonClass: "ui-layout-button",
      minSize: 0,
      maxSize: 0,
      spacing_open: 6,
      spacing_closed: 6,
      togglerLength_open: 50,
      togglerLength_closed: 50,
      togglerAlign_open: "center",
      togglerAlign_closed: "center",
      togglerContent_open: "",
      togglerContent_closed: "",
      resizerDblClickToggle: !0,
      autoResize: !0,
      autoReopen: !0,
      resizerDragOpacity: 1,
      maskContents: !1,
      maskObjects: !1,
      maskZindex: null,
      resizingGrid: !1,
      livePaneResizing: !1,
      liveContentResizing: !1,
      liveResizingTolerance: 1,
      sliderCursor: "pointer",
      slideTrigger_open: "click",
      slideTrigger_close: "mouseleave",
      slideDelay_open: 300,
      slideDelay_close: 300,
      hideTogglerOnSlide: !1,
      preventQuickSlideClose: a.layout.browser.webkit,
      preventPrematureSlideClose: !1,
      tips: {
        Open: "Open",
        Close: "Close",
        Resize: "Resize",
        Slide: "Slide Open",
        Pin: "Pin",
        Unpin: "Un-Pin",
        noRoomToOpen: "Not enough room to show this panel.",
        minSizeWarning: "Panel has reached its minimum size",
        maxSizeWarning: "Panel has reached its maximum size",
      },
      showOverflowOnHover: !1,
      enableCursorHotkey: !0,
      customHotkeyModifier: "SHIFT",
      fxName: "slide",
      fxSpeed: null,
      fxSettings: {},
      fxOpacityFix: !0,
      animatePaneSizing: !1,
      children: null,
      containerSelector: "",
      initChildren: !0,
      destroyChildren: !0,
      resizeChildren: !0,
      triggerEventsOnLoad: !1,
      triggerEventsDuringLiveResize: !0,
      onshow_start: null,
      onshow_end: null,
      onhide_start: null,
      onhide_end: null,
      onopen_start: null,
      onopen_end: null,
      onclose_start: null,
      onclose_end: null,
      onresize_start: null,
      onresize_end: null,
      onsizecontent_start: null,
      onsizecontent_end: null,
      onswap_start: null,
      onswap_end: null,
      ondrag_start: null,
      ondrag_end: null,
    },
    north: {
      paneSelector: ".ui-layout-north",
      size: "auto",
      resizerCursor: "n-resize",
      customHotkey: "",
    },
    south: {
      paneSelector: ".ui-layout-south",
      size: "auto",
      resizerCursor: "s-resize",
      customHotkey: "",
    },
    east: {
      paneSelector: ".ui-layout-east",
      size: 200,
      resizerCursor: "e-resize",
      customHotkey: "",
    },
    west: {
      paneSelector: ".ui-layout-west",
      size: 200,
      resizerCursor: "w-resize",
      customHotkey: "",
    },
    center: { paneSelector: ".ui-layout-center", minWidth: 0, minHeight: 0 },
  };
  a.layout.optionsMap = {
    layout: "name instanceKey stateManagement effects inset zIndexes errors zIndex scrollToBookmarkOnLoad showErrorMessages maskPanesEarly outset resizeWithWindow resizeWithWindowDelay resizeWithWindowMaxDelay onresizeall onresizeall_start onresizeall_end onload onload_start onload_end onunload onunload_start onunload_end".split(
      " "
    ),
    center: "paneClass contentSelector contentIgnoreSelector findNestedContent applyDemoStyles triggerEventsOnLoad showOverflowOnHover maskContents maskObjects liveContentResizing containerSelector children initChildren resizeChildren destroyChildren onresize onresize_start onresize_end onsizecontent onsizecontent_start onsizecontent_end".split(
      " "
    ),
    noDefault: ["paneSelector", "resizerCursor", "customHotkey"],
  };
  a.layout.transformData = function (b, e) {
    let c = e ? { panes: {}, center: {} } : {},
      f,
      h,
      n,
      m,
      w,
      I,
      N;
    if ("object" !== typeof b) return c;
    for (h in b) {
      for (
        f = c, w = b[h], n = h.split("__"), N = n.length - 1, I = 0;
        I <= N;
        I++
      ) {
        (m = n[I]),
          I === N
            ? a.isPlainObject(w)
              ? (f[m] = a.layout.transformData(w))
              : (f[m] = w)
            : (f[m] || (f[m] = {}), (f = f[m]));
      }
    }
    return c;
  };
  a.layout.backwardCompatibility = {
    map: {
      applyDefaultStyles: "applyDemoStyles",
      childOptions: "children",
      initChildLayout: "initChildren",
      destroyChildLayout: "destroyChildren",
      resizeChildLayout: "resizeChildren",
      resizeNestedLayout: "resizeChildren",
      resizeWhileDragging: "livePaneResizing",
      resizeContentWhileDragging: "liveContentResizing",
      triggerEventsWhileDragging: "triggerEventsDuringLiveResize",
      maskIframesOnResize: "maskContents",
      useStateCookie: "stateManagement.enabled",
      "cookie.autoLoad": "stateManagement.autoLoad",
      "cookie.autoSave": "stateManagement.autoSave",
      "cookie.keys": "stateManagement.stateKeys",
      "cookie.name": "stateManagement.cookie.name",
      "cookie.domain": "stateManagement.cookie.domain",
      "cookie.path": "stateManagement.cookie.path",
      "cookie.expires": "stateManagement.cookie.expires",
      "cookie.secure": "stateManagement.cookie.secure",
      noRoomToOpenTip: "tips.noRoomToOpen",
      togglerTip_open: "tips.Close",
      togglerTip_closed: "tips.Open",
      resizerTip: "tips.Resize",
      sliderTip: "tips.Slide",
    },
    renameOptions: function (b) {
      function e(a, c) {
        for (
          var f = a.split("."),
            h = f.length - 1,
            n = { branch: b, key: f[h] },
            t = 0,
            q;
          t < h;
          t++
        ) {
          (q = f[t]),
            (n.branch =
              void 0 == n.branch[q]
                ? c
                  ? (n.branch[q] = {})
                  : {}
                : n.branch[q]);
        }
        return n;
      }
      let c = a.layout.backwardCompatibility.map,
        f,
        h,
        n,
        m;
      for (m in c) {
        (f = e(m)),
          (n = f.branch[f.key]),
          void 0 !== n &&
            ((h = e(c[m], !0)), (h.branch[h.key] = n), delete f.branch[f.key]);
      }
    },
    renameAllOptions: function (b) {
      const e = a.layout.backwardCompatibility.renameOptions;
      e(b);
      b.defaults &&
        ("object" !== typeof b.panes && (b.panes = {}),
        a.extend(!0, b.panes, b.defaults),
        delete b.defaults);
      b.panes && e(b.panes);
      a.each(a.layout.config.allPanes, (a, c) => {
        b[c] && e(b[c]);
      });
      return b;
    },
  };
  a.fn.layout = function (b) {
    function y(d) {
      if (!d) return !0;
      const p = d.keyCode;
      if (33 > p) return !0;
      let k = { 38: "north", 40: "south", 37: "west", 39: "east" },
        l = d.shiftKey,
        g = d.ctrlKey,
        C,
        G,
        b,
        e;
      g && 37 <= p && 40 >= p && t[k[p]].enableCursorHotkey
        ? (e = k[p])
        : (g || l) &&
          a.each(n.borderPanes, (d, a) => {
            C = t[a];
            G = C.customHotkey;
            b = C.customHotkeyModifier;
            if (
              ((l && "SHIFT" == b) || (g && "CTRL" == b) || (g && l)) &&
              G &&
              p === (isNaN(G) || 9 >= G ? G.toUpperCase().charCodeAt(0) : G)
            ) {
              return (e = a), !1;
            }
          });
      if (!e || !x[e] || !t[e].closable || q[e].isHidden) return !0;
      fa(e);
      d.stopPropagation();
      return (d.returnValue = !1);
    }
    function A(d) {
      if (M()) {
        this && this.tagName && (d = this);
        let p;
        c(d)
          ? (p = x[d])
          : a(d).data("layoutRole")
          ? (p = a(d))
          : a(d)
              .parents()
              .each(function () {
                if (a(this).data("layoutRole")) return (p = a(this)), !1;
              });
        if (p && p.length) {
          const k = p.data("layoutEdge");
          d = q[k];
          d.cssSaved && z(k);
          if (d.isSliding || d.isResizing || d.isClosed) d.cssSaved = !1;
          else {
            const l = { zIndex: t.zIndexes.resizer_normal + 1 },
              g = {},
              C = p.css("overflow"),
              G = p.css("overflowX"),
              b = p.css("overflowY");
            "visible" != C && ((g.overflow = C), (l.overflow = "visible"));
            G &&
              !G.match(/(visible|auto)/) &&
              ((g.overflowX = G), (l.overflowX = "visible"));
            b &&
              !b.match(/(visible|auto)/) &&
              ((g.overflowY = G), (l.overflowY = "visible"));
            d.cssSaved = g;
            p.css(l);
            a.each(n.allPanes, (d, a) => {
              a != k && z(a);
            });
          }
        }
      }
    }
    function z(d) {
      if (M()) {
        this && this.tagName && (d = this);
        let p;
        c(d)
          ? (p = x[d])
          : a(d).data("layoutRole")
          ? (p = a(d))
          : a(d)
              .parents()
              .each(function () {
                if (a(this).data("layoutRole")) return (p = a(this)), !1;
              });
        if (p && p.length) {
          d = p.data("layoutEdge");
          d = q[d];
          const k = d.cssSaved || {};
          d.isSliding ||
            d.isResizing ||
            p.css("zIndex", t.zIndexes.pane_normal);
          p.css(k);
          d.cssSaved = !1;
        }
      }
    }
    var L = a.layout.browser,
      n = a.layout.config,
      H = a.layout.cssWidth,
      w = a.layout.cssHeight,
      I = a.layout.getElementDimensions,
      N = a.layout.getElementStyles,
      Q = a.layout.getEventObject,
      D = a.layout.parsePaneName,
      t = a.extend(!0, {}, a.layout.defaults);
    t.effects = a.extend(!0, {}, a.layout.effects);
    var q = {
        id: `layout${a.now()}`,
        initialized: !1,
        paneResizing: !1,
        panesSliding: {},
        container: {
          innerWidth: 0,
          innerHeight: 0,
          outerWidth: 0,
          outerHeight: 0,
          layoutWidth: 0,
          layoutHeight: 0,
        },
        north: { childIdx: 0 },
        south: { childIdx: 0 },
        east: { childIdx: 0 },
        west: { childIdx: 0 },
        center: { childIdx: 0 },
      },
      V = { north: null, south: null, east: null, west: null, center: null },
      P = {
        data: {},
        set: function (d, a, k) {
          P.clear(d);
          P.data[d] = setTimeout(a, k);
        },
        clear: function (d) {
          const a = P.data;
          a[d] && (clearTimeout(a[d]), delete a[d]);
        },
      },
      W = function (d, p, k) {
        const l = t;
        ((l.showErrorMessages && !k) || (k && l.showDebugMessages)) &&
          a.layout.msg(`${l.name} / ${d}`, !1 !== p);
        return !1;
      },
      J = function (d, p, k) {
        let l = p && c(p),
          g = l ? q[p] : q,
          C = l ? t[p] : t,
          G = t.name,
          b = d + (d.match(/_/) ? "" : "_end"),
          e = b.match(/_end$/) ? b.substr(0, b.length - 4) : "",
          B = C[b] || C[e],
          f = "NC",
          h = [],
          n = l ? x[p] : 0;
        if (l && !n) return f;
        l || "boolean" !== a.type(p) || ((k = p), (p = ""));
        if (B) {
          try {
            c(B) &&
              (B.match(/,/)
                ? ((h = B.split(",")), (B = eval(h[0])))
                : (B = eval(B))),
              a.isFunction(B) &&
                (f = h.length
                  ? B(h[1])
                  : l
                  ? B(p, x[p], g, C, G)
                  : B(F, g, C, G));
          } catch (m) {
            W(
              t.errors.callbackError.replace(
                /EVENT/,
                a.trim(`${p || ""} ${b}`)
              ),
              !1
            ),
              "string" === a.type(m) &&
                string.length &&
                W(`Exception:  ${m}`, !1);
          }
        }
        k ||
          !1 === f ||
          (l
            ? ((C = t[p]),
              (g = q[p]),
              n.triggerHandler(`layoutpane${b}`, [p, n, g, C, G]),
              e && n.triggerHandler(`layoutpane${e}`, [p, n, g, C, G]))
            : (v.triggerHandler(`layout${b}`, [F, g, C, G]),
              e && v.triggerHandler(`layout${e}`, [F, g, C, G])));
        l && "onresize_end" === d && Ha(`${p}`, !0);
        return f;
      },
      Ia = function (d) {
        if (!L.mozilla) {
          const a = x[d];
          "IFRAME" === q[d].tagName
            ? a.css(n.hidden).css(n.visible)
            : a.find("IFRAME").css(n.hidden).css(n.visible);
        }
      },
      na = function (d) {
        let a = x[d];
        d = n[d].dir;
        a = { minWidth: 1001 - H(a, 1e3), minHeight: 1001 - w(a, 1e3) };
        "horz" === d && (a.minSize = a.minHeight);
        "vert" === d && (a.minSize = a.minWidth);
        return a;
      },
      Xa = function (d, p, k) {
        let l = d;
        c(d) ? (l = x[d]) : d.jquery || (l = a(d));
        d = w(l, p);
        l.css({ height: d, visibility: "visible" });
        0 < d && 0 < l.innerWidth()
          ? k &&
            l.data("autoHidden") &&
            (l.show().data("autoHidden", !1),
            L.mozilla || l.css(n.hidden).css(n.visible))
          : k && !l.data("autoHidden") && l.hide().data("autoHidden", !0);
      },
      Z = function (d, p, k) {
        k || (k = n[d].dir);
        c(p) && p.match(/%/) && (p = "100%" === p ? -1 : parseInt(p, 10) / 100);
        if (0 === p) return 0;
        if (1 <= p) return parseInt(p, 10);
        var l = t,
          g = 0;
        "horz" == k
          ? (g =
              u.innerHeight -
              (x.north ? l.north.spacing_open : 0) -
              (x.south ? l.south.spacing_open : 0))
          : "vert" == k &&
            (g =
              u.innerWidth -
              (x.west ? l.west.spacing_open : 0) -
              (x.east ? l.east.spacing_open : 0));
        if (-1 === p) return g;
        if (0 < p) return h(g * p);
        if ("center" == d) return 0;
        k = "horz" === k ? "height" : "width";
        l = x[d];
        d = "height" === k ? S[d] : !1;
        var g = a.layout.showInvisibly(l),
          C = l.css(k),
          b = d ? d.css(k) : 0;
        l.css(k, "auto");
        d && d.css(k, "auto");
        p = "height" === k ? l.outerHeight() : l.outerWidth();
        l.css(k, C).css(g);
        d && d.css(k, b);
        return p;
      },
      $ = function (d, a) {
        var k = x[d],
          l = t[d],
          g = q[d],
          C = a ? l.spacing_open : 0,
          l = a ? l.spacing_closed : 0;
        return !k || g.isHidden
          ? 0
          : g.isClosed || (g.isSliding && a)
          ? l
          : "horz" === n[d].dir
          ? k.outerHeight() + C
          : k.outerWidth() + C;
      },
      T = function (d, a) {
        if (M()) {
          var k = t[d],
            l = q[d],
            g = n[d],
            C = g.dir;
          g.sizeType.toLowerCase();
          var g = void 0 != a ? a : l.isSliding,
            b = k.spacing_open,
            c = n.oppositeEdge[d],
            r = q[c],
            B = x[c],
            h =
              !B || !1 === r.isVisible || r.isSliding
                ? 0
                : "horz" == C
                ? B.outerHeight()
                : B.outerWidth(),
            c =
              (!B || r.isHidden
                ? 0
                : t[c][
                    !1 !== r.isClosed ? "spacing_closed" : "spacing_open"
                  ]) || 0,
            r = "horz" == C ? u.innerHeight : u.innerWidth,
            B = na("center"),
            B =
              "horz" == C
                ? e(t.center.minHeight, B.minHeight)
                : e(t.center.minWidth, B.minWidth),
            g = r - b - (g ? 0 : Z("center", B, C) + h + c),
            C = (l.minSize = e(Z(d, k.minSize), na(d).minSize)),
            g = (l.maxSize = f(k.maxSize ? Z(d, k.maxSize) : 1e5, g)),
            l = (l.resizerPosition = {}),
            b = u.inset.top,
            h = u.inset.left,
            c = u.innerWidth,
            r = u.innerHeight,
            k = k.spacing_open;
          switch (d) {
            case "north":
              l.min = b + C;
              l.max = b + g;
              break;
            case "west":
              l.min = h + C;
              l.max = h + g;
              break;
            case "south":
              l.min = b + r - g - k;
              l.max = b + r - C - k;
              break;
            case "east":
              (l.min = h + c - g - k), (l.max = h + c - C - k);
          }
        }
      },
      wa = function (d, p) {
        var k = a(d),
          l = k.data("layoutRole"),
          g = k.data("layoutEdge"),
          C = t[g][`${l}Class`],
          g = `-${g}`,
          b = k.hasClass(`${C}-closed`) ? "-closed" : "-open",
          e = "-closed" === b ? "-open" : "-closed",
          b = `${C}-hover ${C + g}-hover ${C + b}-hover ${C + g + b}-hover `;
        p && (b += `${C + e}-hover ${C + g + e}-hover `);
        "resizer" == l &&
          k.hasClass(`${C}-sliding`) &&
          (b += `${C}-sliding-hover ${C + g}-sliding-hover `);
        return a.trim(b);
      },
      xa = function (d, p) {
        const k = a(p || this);
        d && "toggler" === k.data("layoutRole") && d.stopPropagation();
        k.addClass(wa(k));
      },
      Y = function (d, p) {
        const k = a(p || this);
        k.removeClass(wa(k, !0));
      },
      Ja = function (d) {
        d = a(this).data("layoutEdge");
        const p = q[d];
        a(document);
        p.isResizing ||
          q.paneResizing ||
          (t.maskPanesEarly && la(d, { resizing: !0 }));
      },
      Ka = function (d, p) {
        const k = p || this,
          l = a(k).data("layoutEdge"),
          g = `${l}ResizerLeave`;
        a(document);
        P.clear(`${l}_openSlider`);
        P.clear(g);
        p
          ? t.maskPanesEarly && !q.paneResizing && oa()
          : P.set(
              g,
              () => {
                Ka(d, k);
              },
              200
            );
      },
      M = function () {
        return q.initialized || q.creatingLayout ? !0 : pa();
      },
      pa = function (d) {
        const p = t;
        if (!v.is(":visible")) {
          return (
            !d &&
              L.webkit &&
              "BODY" === v[0].tagName &&
              setTimeout(() => {
                pa(!0);
              }, 50),
            !1
          );
        }
        if (!La("center").length) return W(p.errors.centerPaneMissing);
        q.creatingLayout = !0;
        a.extend(u, I(v, p.inset));
        Ya();
        p.scrollToBookmarkOnLoad &&
          ((d = self.location), d.hash && d.replace(d.hash));
        F.hasParentLayout
          ? (p.resizeWithWindow = !1)
          : p.resizeWithWindow && a(window).bind(`resize.${O}`, Za);
        delete q.creatingLayout;
        q.initialized = !0;
        m(F, a.layout.onReady);
        J("onload_end");
        return !0;
      },
      ya = function (d, p) {
        const k = D.call(this, d),
          l = x[k];
        if (l) {
          var g = S[k],
            b = q[k],
            e = t[k],
            c = t.stateManagement || {},
            e = p ? (e.children = p) : e.children;
          if (a.isPlainObject(e)) e = [e];
          else if (!e || !a.isArray(e)) return;
          a.each(e, (d, p) => {
            a.isPlainObject(p) &&
              (p.containerSelector ? l.find(p.containerSelector) : g || l).each(
                function () {
                  var d = a(this),
                    g = d.data("layout");
                  if (!g) {
                    Ma({ container: d, options: p }, b);
                    if (c.includeChildren && q.stateData[k]) {
                      var g = (q.stateData[k].children || {})[p.instanceKey],
                        l =
                          p.stateManagement ||
                          (p.stateManagement = { autoLoad: !0 });
                      !0 === l.autoLoad &&
                        g &&
                        ((l.autoSave = !1),
                        (l.includeChildren = !0),
                        (l.autoLoad = a.extend(!0, {}, g)));
                    }
                    (g = d.layout(p)) && qa(k, g);
                  }
                }
              );
          });
        }
      },
      Ma = function (d, a) {
        let k = d.container,
          l = d.options,
          g = l.stateManagement,
          b = l.instanceKey || k.data("layoutInstanceKey");
        b || (b = (g && g.cookie ? g.cookie.name : "") || l.name);
        b = b
          ? b.replace(/[^\w-]/gi, "_").replace(/_{2,}/g, "_")
          : `layout${++a.childIdx}`;
        l.instanceKey = b;
        k.data("layoutInstanceKey", b);
        return b;
      },
      qa = function (d, p) {
        let k = x[d],
          l = V[d],
          g = q[d];
        a.isPlainObject(l) &&
          (a.each(l, (d, a) => {
            a.destroyed && delete l[d];
          }),
          a.isEmptyObject(l) && (l = V[d] = null));
        p || l || (p = k.data("layout"));
        p &&
          ((p.hasParentLayout = !0),
          (k = p.options),
          Ma(p, g),
          l || (l = V[d] = {}),
          (l[k.instanceKey] = p.container.data("layout")));
        F[d].children = V[d];
        p || ya(d);
      },
      Za = function () {
        let d = t,
          a = Number(d.resizeWithWindowDelay);
        10 > a && (a = 100);
        P.clear("winResize");
        P.set(
          "winResize",
          () => {
            P.clear("winResize");
            P.clear("winResizeRepeater");
            const a = I(v, d.inset);
            (a.innerWidth === u.innerWidth &&
              a.innerHeight === u.innerHeight) ||
              ga();
          },
          a
        );
        P.data.winResizeRepeater || Na();
      },
      Na = function () {
        const d = Number(t.resizeWithWindowMaxDelay);
        0 < d &&
          P.set(
            "winResizeRepeater",
            () => {
              Na();
              ga();
            },
            d
          );
      },
      Oa = function () {
        J("onunload_start");
        m(F, a.layout.onUnload);
        J("onunload_end");
      },
      Pa = function (d) {
        d = d ? d.split(",") : n.borderPanes;
        a.each(d, (d, k) => {
          const l = t[k];
          if (l.enableCursorHotkey || l.customHotkey) {
            return a(document).bind(`keydown.${O}`, y), !1;
          }
        });
      },
      $a = function () {
        function d(d) {
          const k = t[d],
            g = t.panes;
          k.fxSettings || (k.fxSettings = {});
          g.fxSettings || (g.fxSettings = {});
          a.each(["_open", "_close", "_size"], (p, l) => {
            let b = `fxName${l}`,
              C = `fxSpeed${l}`,
              e = `fxSettings${l}`,
              c = (k[b] = k[b] || g[b] || k.fxName || g.fxName || "none"),
              f =
                a.effects &&
                (a.effects[c] || (a.effects.effect && a.effects.effect[c]));
            ("none" !== c && t.effects[c] && f) || (c = k[b] = "none");
            c = t.effects[c] || {};
            b = c.all || null;
            c = c[d] || null;
            k[C] = k[C] || g[C] || k.fxSpeed || g.fxSpeed || null;
            k[e] = a.extend(
              !0,
              {},
              b,
              c,
              g.fxSettings,
              k.fxSettings,
              g[e],
              k[e]
            );
          });
          delete k.fxName;
          delete k.fxSpeed;
          delete k.fxSettings;
        }
        let p, k, l, g, C, c;
        b = a.layout.transformData(b, !0);
        b = a.layout.backwardCompatibility.renameAllOptions(b);
        if (!a.isEmptyObject(b.panes)) {
          p = a.layout.optionsMap.noDefault;
          g = 0;
          for (C = p.length; g < C; g++) (l = p[g]), delete b.panes[l];
          p = a.layout.optionsMap.layout;
          g = 0;
          for (C = p.length; g < C; g++) (l = p[g]), delete b.panes[l];
        }
        p = a.layout.optionsMap.layout;
        let f = a.layout.config.optionRootKeys;
        for (l in b) {
          (g = b[l]),
            0 > a.inArray(l, f) &&
              0 > a.inArray(l, p) &&
              (b.panes[l] ||
                (b.panes[l] = a.isPlainObject(g) ? a.extend(!0, {}, g) : g),
              delete b[l]);
        }
        a.extend(!0, t, b);
        a.each(n.allPanes, (g, e) => {
          n[e] = a.extend(!0, {}, n.panes, n[e]);
          k = t.panes;
          c = t[e];
          if ("center" === e) {
            for (
              p = a.layout.optionsMap.center, g = 0, C = p.length;
              g < C;
              g++
            ) {
              (l = p[g]), b.center[l] || (!b.panes[l] && c[l]) || (c[l] = k[l]);
            }
          } else {
            (c = t[e] = a.extend(!0, {}, k, c)),
              d(e),
              c.resizerClass || (c.resizerClass = "ui-layout-resizer"),
              c.togglerClass || (c.togglerClass = "ui-layout-toggler");
          }
          c.paneClass || (c.paneClass = "ui-layout-pane");
        });
        g = b.zIndex;
        f = t.zIndexes;
        0 < g &&
          ((f.pane_normal = g),
          (f.content_mask = e(g + 1, f.content_mask)),
          (f.resizer_normal = e(g + 2, f.resizer_normal)));
        delete t.panes;
      },
      La = function (d) {
        d = t[d].paneSelector;
        if ("#" === d.substr(0, 1)) return v.find(d).eq(0);
        const a = v.children(d).eq(0);
        return a.length ? a : v.children("form:first").children(d).eq(0);
      },
      Ya = function (d) {
        D(d);
        a.each(n.allPanes, (d, a) => {
          Qa(a, !0);
        });
        za();
        a.each(n.borderPanes, (d, a) => {
          x[a] && q[a].isVisible && (T(a), aa(a));
        });
        ba("center");
        a.each(n.allPanes, (d, a) => {
          Ra(a);
        });
      },
      Qa = function (d, a) {
        if (a || M()) {
          let k = t[d],
            l = q[d],
            g = n[d],
            b = g.dir,
            c = "center" === d,
            h = {},
            r = x[d],
            B,
            m;
          r ? Aa(d, !1, !0, !1) : (S[d] = !1);
          r = x[d] = La(d);
          if (r.length) {
            r.data("layoutCSS") ||
              r.data(
                "layoutCSS",
                N(
                  r,
                  "position,top,left,bottom,right,width,height,overflow,zIndex,display,backgroundColor,padding,margin,border"
                )
              );
            F[d] = {
              name: d,
              pane: x[d],
              content: S[d],
              options: t[d],
              state: q[d],
              children: V[d],
            };
            r.data({
              parentLayout: F,
              layoutPane: F[d],
              layoutEdge: d,
              layoutRole: "pane",
            })
              .css(g.cssReq)
              .css("zIndex", t.zIndexes.pane_normal)
              .css(k.applyDemoStyles ? g.cssDemo : {})
              .addClass(`${k.paneClass} ${k.paneClass}-${d}`)
              .bind(`mouseenter.${O}`, xa)
              .bind(`mouseleave.${O}`, Y);
            g = {
              hide: "",
              show: "",
              toggle: "",
              close: "",
              open: "",
              slideOpen: "",
              slideClose: "",
              slideToggle: "",
              size: "sizePane",
              sizePane: "sizePane",
              sizeContent: "",
              sizeHandles: "",
              enableClosable: "",
              disableClosable: "",
              enableSlideable: "",
              disableSlideable: "",
              enableResizable: "",
              disableResizable: "",
              swapPanes: "swapPanes",
              swap: "swapPanes",
              move: "swapPanes",
              removePane: "removePane",
              remove: "removePane",
              createChildren: "",
              resizeChildren: "",
              resizeAll: "resizeAll",
              resizeLayout: "resizeAll",
            };
            for (m in g) {
              r.bind(`layoutpane${m.toLowerCase()}.${O}`, F[g[m] || m]);
            }
            Ba(d, !1);
            c ||
              ((B = l.size = Z(d, k.size)),
              (c = Z(d, k.minSize) || 1),
              (m = Z(d, k.maxSize) || 1e5),
              0 < B && (B = e(f(B, m), c)),
              (l.autoResize = k.autoResize),
              (l.isClosed = !1),
              (l.isSliding = !1),
              (l.isResizing = !1),
              (l.isHidden = !1),
              l.pins || (l.pins = []));
            l.tagName = r[0].tagName;
            l.edge = d;
            l.noRoom = !1;
            l.isVisible = !0;
            Sa(d);
            "horz" === b
              ? (h.height = w(r, B))
              : "vert" === b && (h.width = H(r, B));
            r.css(h);
            "horz" != b && ba(d, !0);
            q.initialized && (za(d), Pa(d));
            k.initClosed && k.closable && !k.initHidden
              ? ca(d, !0, !0)
              : k.initHidden || k.initClosed
              ? Ca(d)
              : l.noRoom || r.css("display", "block");
            r.css("visibility", "visible");
            k.showOverflowOnHover && r.hover(A, z);
            q.initialized && Ra(d);
          } else x[d] = !1;
        }
      },
      Ra = function (d) {
        const a = x[d],
          k = q[d],
          l = t[d];
        a &&
          (a.data("layout") && qa(d, a.data("layout")),
          k.isVisible &&
            (q.initialized ? ga() : ha(d),
            l.triggerEventsOnLoad ? J("onresize_end", d) : Ha(d, !0)),
          l.initChildren && l.children && ya(d));
      },
      Sa = function (d) {
        d = d ? d.split(",") : n.borderPanes;
        a.each(d, (d, a) => {
          const l = x[a],
            g = K[a],
            b = q[a],
            e = n[a].side,
            c = {};
          if (l) {
            switch (a) {
              case "north":
                c.top = u.inset.top;
                c.left = u.inset.left;
                c.right = u.inset.right;
                break;
              case "south":
                c.bottom = u.inset.bottom;
                c.left = u.inset.left;
                c.right = u.inset.right;
                break;
              case "west":
                c.left = u.inset.left;
                break;
              case "east":
                c.right = u.inset.right;
            }
            l.css(c);
            g && b.isClosed
              ? g.css(e, u.inset[e])
              : g && !b.isHidden && g.css(e, u.inset[e] + $(a));
          }
        });
      },
      za = function (d) {
        d = d ? d.split(",") : n.borderPanes;
        a.each(d, (d, k) => {
          var l = x[k];
          K[k] = !1;
          R[k] = !1;
          if (l) {
            var l = t[k],
              g = q[k],
              b =
                "#" === l.paneSelector.substr(0, 1)
                  ? l.paneSelector.substr(1)
                  : "",
              e = l.resizerClass,
              c = l.togglerClass,
              f = `-${k}`,
              h = F[k],
              m = (h.resizer = K[k] = a("<div></div>")),
              h = (h.toggler = l.closable ? (R[k] = a("<div></div>")) : !1);
            !g.isVisible &&
              l.slidable &&
              m.attr("title", l.tips.Slide).css("cursor", l.sliderCursor);
            m.attr("id", b ? `${b}-resizer` : "")
              .data({
                parentLayout: F,
                layoutPane: F[k],
                layoutEdge: k,
                layoutRole: "resizer",
              })
              .css(n.resizers.cssReq)
              .css("zIndex", t.zIndexes.resizer_normal)
              .css(l.applyDemoStyles ? n.resizers.cssDemo : {})
              .addClass(`${e} ${e}${f}`)
              .hover(xa, Y)
              .hover(Ja, Ka)
              .mousedown(a.layout.disableTextSelection)
              .mouseup(a.layout.enableTextSelection)
              .appendTo(v);
            a.fn.disableSelection && m.disableSelection();
            l.resizerDblClickToggle && m.bind(`dblclick.${O}`, fa);
            h &&
              (h
                .attr("id", b ? `${b}-toggler` : "")
                .data({
                  parentLayout: F,
                  layoutPane: F[k],
                  layoutEdge: k,
                  layoutRole: "toggler",
                })
                .css(n.togglers.cssReq)
                .css(l.applyDemoStyles ? n.togglers.cssDemo : {})
                .addClass(`${c} ${c}${f}`)
                .hover(xa, Y)
                .bind("mouseenter", Ja)
                .appendTo(m),
              l.togglerContent_open &&
                a(`<span>${l.togglerContent_open}</span>`)
                  .data({ layoutEdge: k, layoutRole: "togglerContent" })
                  .data("layoutRole", "togglerContent")
                  .data("layoutEdge", k)
                  .addClass("content content-open")
                  .css("display", "none")
                  .appendTo(h),
              l.togglerContent_closed &&
                a(`<span>${l.togglerContent_closed}</span>`)
                  .data({ layoutEdge: k, layoutRole: "togglerContent" })
                  .addClass("content content-closed")
                  .css("display", "none")
                  .appendTo(h),
              Ta(k));
            ab(k);
            g.isVisible ? Da(k) : (ra(k), ea(k, !0));
          }
        });
        ia();
      },
      Ba = function (d, a) {
        if (M()) {
          let k = t[d],
            l = k.contentSelector,
            g = F[d],
            b = x[d],
            e;
          l &&
            (e = g.content = S[d] = k.findNestedContent
              ? b.find(l).eq(0)
              : b.children(l).eq(0));
          e && e.length
            ? (e.data("layoutRole", "content"),
              e.data("layoutCSS") || e.data("layoutCSS", N(e, "height")),
              e.css(n.content.cssReq),
              k.applyDemoStyles &&
                (e.css(n.content.cssDemo), b.css(n.content.cssDemoPane)),
              b.css("overflowX").match(/(scroll|auto)/) &&
                b.css("overflow", "hidden"),
              (q[d].content = {}),
              !1 !== a && ha(d))
            : (g.content = S[d] = !1);
        }
      },
      ab = function (d) {
        const p = a.layout.plugins.draggable;
        d = d ? d.split(",") : n.borderPanes;
        a.each(d, (d, g) => {
          let b = t[g];
          if (!p || !x[g] || !b.resizable) return (b.resizable = !1), !0;
          let e = q[g],
            c = t.zIndexes,
            f = n[g],
            h = "horz" == f.dir ? "top" : "left",
            m = K[g],
            E = b.resizerClass,
            X = 0,
            u,
            w,
            y = `${E}-drag`,
            A = `${E}-${g}-drag`,
            H = `${E}-dragging`,
            I = `${E}-${g}-dragging`,
            F = `${E}-dragging-limit`,
            D = `${E}-${g}-dragging-limit`,
            z = !1;
          e.isClosed ||
            m.attr("title", b.tips.Resize).css("cursor", b.resizerCursor);
          m.draggable({
            containment: v[0],
            axis: "horz" == f.dir ? "y" : "x",
            delay: 0,
            distance: 1,
            grid: b.resizingGrid,
            helper: "clone",
            opacity: b.resizerDragOpacity,
            addClasses: !1,
            zIndex: c.resizer_drag,
            start: function (d, a) {
              b = t[g];
              e = q[g];
              w = b.livePaneResizing;
              if (!1 === J("ondrag_start", g)) return !1;
              e.isResizing = !0;
              q.paneResizing = g;
              P.clear(`${g}_closeSlider`);
              T(g);
              u = e.resizerPosition;
              X = a.position[h];
              m.addClass(`${y} ${A}`);
              z = !1;
              la(g, { resizing: !0 });
            },
            drag: function (d, a) {
              z ||
                (a.helper
                  .addClass(`${H} ${I}`)
                  .css({ right: "auto", bottom: "auto" })
                  .children()
                  .css("visibility", "hidden"),
                (z = !0),
                e.isSliding && x[g].css("zIndex", c.pane_sliding));
              let p = 0;
              a.position[h] < u.min
                ? ((a.position[h] = u.min), (p = -1))
                : a.position[h] > u.max && ((a.position[h] = u.max), (p = 1));
              p
                ? (a.helper.addClass(`${F} ${D}`),
                  (window.defaultStatus =
                    (0 < p && g.match(/(north|west)/)) ||
                    (0 > p && g.match(/(south|east)/))
                      ? b.tips.maxSizeWarning
                      : b.tips.minSizeWarning))
                : (a.helper.removeClass(`${F} ${D}`),
                  (window.defaultStatus = ""));
              w &&
                Math.abs(a.position[h] - X) >= b.liveResizingTolerance &&
                ((X = a.position[h]), k(d, a, g));
            },
            stop: function (d, p) {
              a("body").enableSelection();
              window.defaultStatus = "";
              m.removeClass(`${y} ${A}`);
              e.isResizing = !1;
              q.paneResizing = !1;
              k(d, p, g, !0);
            },
          });
        });
        var k = function (d, a, k, p) {
          const b = a.position,
            e = n[k];
          d = t[k];
          a = q[k];
          let c;
          switch (k) {
            case "north":
              c = b.top;
              break;
            case "west":
              c = b.left;
              break;
            case "south":
              c = u.layoutHeight - b.top - d.spacing_open;
              break;
            case "east":
              c = u.layoutWidth - b.left - d.spacing_open;
          }
          c -= u.inset[e.side];
          p
            ? (!1 !== J("ondrag_end", k) && sa(k, c, !1, !0),
              oa(!0),
              a.isSliding && la(k, { resizing: !0 }))
            : Math.abs(c - a.size) < d.liveResizingTolerance ||
              (sa(k, c, !1, !0), U.each(Ua));
        };
      },
      Ua = function () {
        var d = a(this),
          p = d.data("layoutMask"),
          p = q[p];
        "IFRAME" == p.tagName &&
          p.isVisible &&
          d.css({
            top: p.offsetTop,
            left: p.offsetLeft,
            width: p.outerWidth,
            height: p.outerHeight,
          });
      },
      la = function (d, p) {
        let k = n[d],
          b = ["center"],
          g = t.zIndexes,
          e = a.extend(
            {
              objectsOnly: !1,
              animation: !1,
              resizing: !0,
              sliding: q[d].isSliding,
            },
            p
          ),
          c,
          f;
        e.resizing && b.push(d);
        e.sliding && b.push(n.oppositeEdge[d]);
        "horz" === k.dir && (b.push("west"), b.push("east"));
        a.each(b, (d, a) => {
          f = q[a];
          c = t[a];
          f.isVisible &&
            (c.maskObjects || (!e.objectsOnly && c.maskContents)) &&
            bb(a).each(function () {
              Ua.call(this);
              this.style.zIndex = f.isSliding
                ? g.pane_sliding + 1
                : g.pane_normal + 1;
              this.style.display = "block";
            });
        });
      },
      oa = function (d) {
        if (d || !q.paneResizing) U.hide();
        else if (!d && !a.isEmptyObject(q.panesSliding)) {
          d = U.length - 1;
          for (var b, k; 0 <= d; d--) {
            (k = U.eq(d)),
              (b = k.data("layoutMask")),
              t[b].maskObjects || k.hide();
          }
        }
      },
      bb = function (d) {
        for (var b = a([]), k, l = 0, g = U.length; l < g; l++) {
          (k = U.eq(l)), k.data("layoutMask") === d && (b = b.add(k));
        }
        if (b.length) return b;
        b = x[d];
        k = q[d];
        var l = t[d],
          g = t.zIndexes,
          e,
          c,
          f,
          h,
          n;
        if (l.maskContents || l.maskObjects) {
          for (n = 0; n < (l.maskObjects ? 2 : 1); n++) {
            (e = l.maskObjects && 0 == n),
              (c = document.createElement(e ? "iframe" : "div")),
              (f = a(c).data("layoutMask", d)),
              (c.className = `ui-layout-mask ui-layout-mask-${d}`),
              (h = c.style),
              (h.background = "#FFF"),
              (h.position = "absolute"),
              (h.display = "block"),
              e
                ? ((c.src = "about:blank"),
                  (c.frameborder = 0),
                  (h.border = 0),
                  (h.opacity = 0),
                  (h.filter = "Alpha(Opacity='0')"))
                : ((h.opacity = 0.001), (h.filter = "Alpha(Opacity='1')")),
              "IFRAME" == k.tagName
                ? ((h.zIndex = g.pane_normal + 1), v.append(c))
                : (f.addClass("ui-layout-mask-inside-pane"),
                  (h.zIndex = l.maskZindex || g.content_mask),
                  (h.top = 0),
                  (h.left = 0),
                  (h.width = "100%"),
                  (h.height = "100%"),
                  b.append(c)),
              (U = U.add(c));
          }
          d = U;
        } else d = a([]);
        return d;
      },
      Aa = function (d, b, k, l) {
        if (M()) {
          d = D.call(this, d);
          let g = x[d],
            e = S[d],
            c = K[d],
            f = R[d];
          g && a.isEmptyObject(g.data()) && (g = !1);
          e && a.isEmptyObject(e.data()) && (e = !1);
          c && a.isEmptyObject(c.data()) && (c = !1);
          f && a.isEmptyObject(f.data()) && (f = !1);
          g && g.stop(!0, !0);
          let h = t[d],
            n = V[d],
            m = a.isPlainObject(n) && !a.isEmptyObject(n);
          l = void 0 !== l ? l : h.destroyChildren;
          m &&
            l &&
            (a.each(n, (d, a) => {
              a.destroyed || a.destroy(!0);
              a.destroyed && delete n[d];
            }),
            a.isEmptyObject(n) && ((n = V[d] = null), (m = !1)));
          g && b && !m
            ? g.remove()
            : g &&
              g[0] &&
              ((b = h.paneClass),
              (l = `${b}-${d}`),
              (b = [
                b,
                `${b}-open`,
                `${b}-closed`,
                `${b}-sliding`,
                l,
                `${l}-open`,
                `${l}-closed`,
                `${l}-sliding`,
              ]),
              a.merge(b, wa(g, !0)),
              g
                .removeClass(b.join(" "))
                .removeData("parentLayout")
                .removeData("layoutPane")
                .removeData("layoutRole")
                .removeData("layoutEdge")
                .removeData("autoHidden")
                .unbind(`.${O}`),
              m && e
                ? (e.width(e.width()),
                  a.each(n, (d, a) => {
                    a.resizeAll();
                  }))
                : e &&
                  e
                    .css(e.data("layoutCSS"))
                    .removeData("layoutCSS")
                    .removeData("layoutRole"),
              g.data("layout") ||
                g.css(g.data("layoutCSS")).removeData("layoutCSS"));
          f && f.remove();
          c && c.remove();
          F[d] = x[d] = S[d] = K[d] = R[d] = !1;
          k || ga();
        }
      },
      ta = function (a) {
        const b = x[a],
          k = b[0].style;
        t[a].useOffscreenClose
          ? (b.data(n.offscreenReset) ||
              b.data(n.offscreenReset, { left: k.left, right: k.right }),
            b.css(n.offscreenCSS))
          : b.hide().removeData(n.offscreenReset);
      },
      Va = function (a) {
        const b = x[a];
        a = t[a];
        const k = n.offscreenCSS,
          e = b.data(n.offscreenReset),
          g = b[0].style;
        b.show().removeData(n.offscreenReset);
        a.useOffscreenClose &&
          e &&
          (g.left == k.left && (g.left = e.left),
          g.right == k.right && (g.right = e.right));
      },
      Ca = function (a, b) {
        if (M()) {
          const k = D.call(this, a),
            e = t[k],
            g = q[k],
            c = x[k],
            f = K[k];
          "center" === k ||
            !c ||
            g.isHidden ||
            (q.initialized && !1 === J("onhide_start", k)) ||
            ((g.isSliding = !1),
            delete q.panesSliding[k],
            f && f.hide(),
            !q.initialized || g.isClosed
              ? ((g.isClosed = !0),
                (g.isHidden = !0),
                (g.isVisible = !1),
                q.initialized || ta(k),
                ba("horz" === n[k].dir ? "" : "center"),
                (q.initialized || e.triggerEventsOnLoad) && J("onhide_end", k))
              : ((g.isHiding = !0), ca(k, !1, b)));
        }
      },
      ua = function (a, b, k, e) {
        if (M()) {
          a = D.call(this, a);
          const g = q[a],
            c = x[a];
          "center" !== a &&
            c &&
            g.isHidden &&
            !1 !== J("onshow_start", a) &&
            ((g.isShowing = !0),
            (g.isSliding = !1),
            delete q.panesSliding[a],
            !1 === b ? ca(a, !0) : ja(a, !1, k, e));
        }
      },
      fa = function (a, b) {
        if (M()) {
          const k = Q(a),
            e = D.call(this, a),
            g = q[e];
          k && k.stopImmediatePropagation();
          g.isHidden ? ua(e) : g.isClosed ? ja(e, Boolean(b)) : ca(e);
        }
      },
      cb = function (a, b) {
        const k = q[a];
        ta(a);
        k.isClosed = !0;
        k.isVisible = !1;
        b && ra(a);
      },
      ca = function (a, b, k, e) {
        function g() {
          r.isMoving = !1;
          ea(c, !0);
          const a = n.oppositeEdge[c];
          q[a].noRoom && (T(a), aa(a));
          e ||
            (!q.initialized && !h.triggerEventsOnLoad) ||
            (u || J("onclose_end", c),
            u && J("onshow_end", c),
            E && J("onhide_end", c));
        }
        var c = D.call(this, a);
        if ("center" !== c) {
          if (!q.initialized && x[c]) cb(c, !0);
          else if (M()) {
            var f = x[c],
              h = t[c],
              r = q[c],
              m,
              u,
              E;
            v.queue((a) => {
              if (
                !f ||
                (!h.closable && !r.isShowing && !r.isHiding) ||
                (!b && r.isClosed && !r.isShowing)
              ) {
                return a();
              }
              const d = !r.isShowing && !1 === J("onclose_start", c);
              u = r.isShowing;
              E = r.isHiding;
              delete r.isShowing;
              delete r.isHiding;
              if (d) return a();
              m = !k && !r.isClosed && "none" != h.fxName_close;
              r.isMoving = !0;
              r.isClosed = !0;
              r.isVisible = !1;
              E ? (r.isHidden = !0) : u && (r.isHidden = !1);
              r.isSliding
                ? ma(c, !1)
                : ba("horz" === n[c].dir ? "" : "center", !1);
              ra(c);
              m
                ? (va(c, !0),
                  f.hide(
                    h.fxName_close,
                    h.fxSettings_close,
                    h.fxSpeed_close,
                    () => {
                      va(c, !1);
                      r.isClosed && g();
                      a();
                    }
                  ))
                : (ta(c), g(), a());
            });
          }
        }
      },
      ra = function (d) {
        if (K[d]) {
          const b = K[d],
            k = R[d],
            e = t[d],
            g = q[d],
            c = n[d].side,
            f = e.resizerClass,
            h = e.togglerClass,
            r = `-${d}`;
          b.css(c, u.inset[c])
            .removeClass(`${f}-open ${f}${r}-open`)
            .removeClass(`${f}-sliding ${f}${r}-sliding`)
            .addClass(`${f}-closed ${f}${r}-closed`);
          g.isHidden && b.hide();
          e.resizable &&
            a.layout.plugins.draggable &&
            b
              .draggable("disable")
              .removeClass("ui-state-disabled")
              .css("cursor", "default")
              .attr("title", "");
          k &&
            (k
              .removeClass(`${h}-open ${h}${r}-open`)
              .addClass(`${h}-closed ${h}${r}-closed`)
              .attr("title", e.tips.Open),
            k.children(".content-open").hide(),
            k.children(".content-closed").css("display", "block"));
          Ea(d, !1);
          q.initialized && ia();
        }
      },
      ja = function (a, b, k, e) {
        function g() {
          r.isMoving = !1;
          Ia(c);
          r.isSliding || ba("vert" == n[c].dir ? "center" : "", !1);
          Da(c);
        }
        if (M()) {
          var c = D.call(this, a),
            f = x[c],
            h = t[c],
            r = q[c],
            m,
            u;
          "center" !== c &&
            v.queue((a) => {
              if (
                !f ||
                (!h.resizable && !h.closable && !r.isShowing) ||
                (r.isVisible && !r.isSliding)
              ) {
                return a();
              }
              if (r.isHidden && !r.isShowing) a(), ua(c, !0);
              else {
                r.autoResize && r.size != h.size
                  ? da(c, h.size, !0, !0, !0)
                  : T(c, b);
                const d = J("onopen_start", c);
                if ("abort" === d) return a();
                "NC" !== d && T(c, b);
                if (r.minSize > r.maxSize) {
                  return (
                    Ea(c, !1),
                    !e && h.tips.noRoomToOpen && alert(h.tips.noRoomToOpen),
                    a()
                  );
                }
                b
                  ? ma(c, !0)
                  : r.isSliding
                  ? ma(c, !1)
                  : h.slidable && ea(c, !1);
                r.noRoom = !1;
                aa(c);
                u = r.isShowing;
                delete r.isShowing;
                m = !k && r.isClosed && "none" != h.fxName_open;
                r.isMoving = !0;
                r.isVisible = !0;
                r.isClosed = !1;
                u && (r.isHidden = !1);
                m
                  ? (va(c, !0),
                    f.show(
                      h.fxName_open,
                      h.fxSettings_open,
                      h.fxSpeed_open,
                      () => {
                        va(c, !1);
                        r.isVisible && g();
                        a();
                      }
                    ))
                  : (Va(c), g(), a());
              }
            });
        }
      },
      Da = function (d, b) {
        const k = x[d],
          c = K[d],
          g = R[d],
          e = t[d],
          f = q[d],
          h = n[d].side,
          r = e.resizerClass,
          m = e.togglerClass,
          w = `-${d}`;
        c.css(h, u.inset[h] + $(d))
          .removeClass(`${r}-closed ${r}${w}-closed`)
          .addClass(`${r}-open ${r}${w}-open`);
        f.isSliding
          ? c.addClass(`${r}-sliding ${r}${w}-sliding`)
          : c.removeClass(`${r}-sliding ${r}${w}-sliding`);
        Y(0, c);
        e.resizable && a.layout.plugins.draggable
          ? c
              .draggable("enable")
              .css("cursor", e.resizerCursor)
              .attr("title", e.tips.Resize)
          : f.isSliding || c.css("cursor", "default");
        g &&
          (g
            .removeClass(`${m}-closed ${m}${w}-closed`)
            .addClass(`${m}-open ${m}${w}-open`)
            .attr("title", e.tips.Close),
          Y(0, g),
          g.children(".content-closed").hide(),
          g.children(".content-open").css("display", "block"));
        Ea(d, !f.isSliding);
        a.extend(f, I(k));
        q.initialized && (ia(), ha(d, !0));
        !b &&
          (q.initialized || e.triggerEventsOnLoad) &&
          k.is(":visible") &&
          (J("onopen_end", d),
          f.isShowing && J("onshow_end", d),
          q.initialized && J("onresize_end", d));
      },
      Wa = function (a) {
        function b() {
          g.isClosed ? g.isMoving || ja(c, !0) : ma(c, !0);
        }
        if (M()) {
          var k = Q(a),
            c = D.call(this, a),
            g = q[c];
          a = t[c].slideDelay_open;
          "center" !== c &&
            (k && k.stopImmediatePropagation(),
            g.isClosed && k && "mouseenter" === k.type && 0 < a
              ? P.set(`${c}_openSlider`, b, a)
              : b());
        }
      },
      Fa = function (d) {
        function b() {
          g.isClosed ? ma(l, !1) : g.isMoving || ca(l);
        }
        if (M()) {
          var c = Q(d),
            l = D.call(this, d);
          d = t[l];
          var g = q[l],
            f = g.isMoving ? 1e3 : 300;
          "center" === l ||
            g.isClosed ||
            g.isResizing ||
            ("click" === d.slideTrigger_close
              ? b()
              : (d.preventQuickSlideClose && g.isMoving) ||
                (d.preventPrematureSlideClose &&
                  c &&
                  a.layout.isMouseOverElem(c, x[l])) ||
                (c
                  ? P.set(`${l}_closeSlider`, b, e(d.slideDelay_close, f))
                  : b()));
        }
      },
      va = function (a, b) {
        const c = x[a],
          e = q[a],
          g = t[a],
          f = t.zIndexes;
        b
          ? (la(a, { animation: !0, objectsOnly: !0 }),
            c.css({ zIndex: f.pane_animate }),
            "south" == a
              ? c.css({ top: u.inset.top + u.innerHeight - c.outerHeight() })
              : "east" == a &&
                c.css({ left: u.inset.left + u.innerWidth - c.outerWidth() }))
          : (oa(),
            c.css({ zIndex: e.isSliding ? f.pane_sliding : f.pane_normal }),
            "south" == a
              ? c.css({ top: "auto" })
              : "east" != a ||
                c.css("left").match(/\-99999/) ||
                c.css({ left: "auto" }),
            L.msie &&
              g.fxOpacityFix &&
              "slide" != g.fxName_open &&
              c.css("filter") &&
              1 == c.css("opacity") &&
              c[0].style.removeAttribute("filter"));
      },
      ea = function (a, b) {
        let c = t[a],
          e = K[a],
          g = c.slideTrigger_open.toLowerCase();
        if (e && (!b || c.slidable)) {
          g.match(/mouseover/)
            ? (g = c.slideTrigger_open = "mouseenter")
            : g.match(/(click|dblclick|mouseenter)/) ||
              (g = c.slideTrigger_open = "click");
          if (c.resizerDblClickToggle && g.match(/click/)) {
            e[b ? "unbind" : "bind"](`dblclick.${O}`, fa);
          }
          e[b ? "bind" : "unbind"](`${g}.${O}`, Wa)
            .css("cursor", b ? c.sliderCursor : "default")
            .attr("title", b ? c.tips.Slide : "");
        }
      },
      ma = function (a, b) {
        function c(b) {
          P.clear(`${a}_closeSlider`);
          b.stopPropagation();
        }
        let e = t[a],
          g = q[a],
          f = t.zIndexes,
          h = e.slideTrigger_close.toLowerCase(),
          n = b ? "bind" : "unbind",
          r = x[a],
          m = K[a];
        P.clear(`${a}_closeSlider`);
        b
          ? ((g.isSliding = !0), (q.panesSliding[a] = !0), ea(a, !1))
          : ((g.isSliding = !1), delete q.panesSliding[a]);
        r.css("zIndex", b ? f.pane_sliding : f.pane_normal);
        m.css("zIndex", b ? f.pane_sliding + 2 : f.resizer_normal);
        h.match(/(click|mouseleave)/) ||
          (h = e.slideTrigger_close = "mouseleave");
        m[n](h, Fa);
        "mouseleave" === h &&
          (r[n](`mouseleave.${O}`, Fa),
          m[n](`mouseenter.${O}`, c),
          r[n](`mouseenter.${O}`, c));
        b
          ? "click" !== h ||
            e.resizable ||
            (m.css("cursor", b ? e.sliderCursor : "default"),
            m.attr("title", b ? e.tips.Close : ""))
          : P.clear(`${a}_closeSlider`);
      },
      aa = function (d, b, c, e) {
        b = t[d];
        let g = q[d],
          f = n[d],
          h = x[d],
          m = K[d],
          r = "vert" === f.dir,
          B = !1;
        if ("center" === d || (r && g.noVerticalRoom)) {
          (B = 0 <= g.maxHeight) && g.noRoom
            ? (Va(d),
              m && m.show(),
              (g.isVisible = !0),
              (g.noRoom = !1),
              r && (g.noVerticalRoom = !1),
              Ia(d))
            : B ||
              g.noRoom ||
              (ta(d), m && m.hide(), (g.isVisible = !1), (g.noRoom = !0));
        }
        "center" !== d &&
          (g.minSize <= g.maxSize
            ? (g.size > g.maxSize
                ? da(d, g.maxSize, c, !0, e)
                : g.size < g.minSize
                ? da(d, g.minSize, c, !0, e)
                : m &&
                  g.isVisible &&
                  h.is(":visible") &&
                  ((c = g.size + u.inset[f.side]),
                  a.layout.cssNum(m, f.side) != c && m.css(f.side, c)),
              g.noRoom &&
                (g.wasOpen && b.closable
                  ? b.autoReopen
                    ? ja(d, !1, !0, !0)
                    : (g.noRoom = !1)
                  : ua(d, g.wasOpen, !0, !0)))
            : g.noRoom ||
              ((g.noRoom = !0),
              (g.wasOpen = !g.isClosed && !g.isSliding),
              g.isClosed || (b.closable ? ca(d, !0, !0) : Ca(d, !0))));
      },
      sa = function (a, b, c, e, g) {
        if (M()) {
          a = D.call(this, a);
          const f = t[a],
            h = q[a];
          g = g || (f.livePaneResizing && !h.isResizing);
          "center" !== a && ((h.autoResize = !1), da(a, b, c, e, g));
        }
      },
      da = function (d, b, c, h, g) {
        function m() {
          for (
            var d = "width" === X ? B.outerWidth() : B.outerHeight(),
              d = [
                {
                  pane: G,
                  count: 1,
                  target: b,
                  actual: d,
                  correct: b === d,
                  attempt: b,
                  cssSize: z,
                },
              ],
              f = d[0],
              h = {},
              l = `Inaccurate size after resizing the ${G}-pane.`;
            !f.correct;

          ) {
            h = { pane: G, count: f.count + 1, target: b };
            h.attempt =
              f.actual > b
                ? e(0, f.attempt - (f.actual - b))
                : e(0, f.attempt + (b - f.actual));
            h.cssSize = ("horz" == n[G].dir ? w : H)(x[G], h.attempt);
            B.css(X, h.cssSize);
            h.actual = "width" == X ? B.outerWidth() : B.outerHeight();
            h.correct = b === h.actual;
            1 === d.length && (W(l, !1, !0), W(f, !1, !0));
            W(h, !1, !0);
            if (3 < d.length) break;
            d.push(h);
            f = d[d.length - 1];
          }
          r.size = b;
          a.extend(r, I(B));
          r.isVisible &&
            B.is(":visible") &&
            (y && y.css(E, b + u.inset[E]), ha(G));
          !c && !Ga && q.initialized && r.isVisible && J("onresize_end", G);
          c ||
            (r.isSliding || ba("horz" == n[G].dir ? "" : "center", Ga, g),
            ia());
          f = n.oppositeEdge[G];
          b < F && q[f].noRoom && (T(f), aa(f, !1, c));
          1 < d.length && W(`${l}\nSee the Error Console for details.`, !0, !0);
        }
        if (M()) {
          var G = D.call(this, d),
            ka = t[G],
            r = q[G],
            B = x[G],
            y = K[G],
            E = n[G].side,
            X = n[G].sizeType.toLowerCase(),
            Ga = r.isResizing && !ka.triggerEventsDuringLiveResize,
            A = !0 !== h && ka.animatePaneSizing,
            F,
            z;
          "center" !== G &&
            v.queue((d) => {
              T(G);
              F = r.size;
              b = Z(G, b);
              b = e(b, Z(G, ka.minSize));
              b = f(b, r.maxSize);
              if (b < r.minSize) d(), aa(G, !1, c);
              else {
                if (!g && b === F) return d();
                r.newSize = b;
                !c && q.initialized && r.isVisible && J("onresize_start", G);
                z = ("horz" == n[G].dir ? w : H)(x[G], b);
                if (A && B.is(":visible")) {
                  var h = a.layout.effects.size[G] || a.layout.effects.size.all,
                    h = ka.fxSettings_size.easing || h.easing,
                    l = t.zIndexes,
                    u = {};
                  u[X] = `${z}px`;
                  r.isMoving = !0;
                  B.css({ zIndex: l.pane_animate })
                    .show()
                    .animate(u, ka.fxSpeed_size, h, () => {
                      B.css({
                        zIndex: r.isSliding ? l.pane_sliding : l.pane_normal,
                      });
                      r.isMoving = !1;
                      delete r.newSize;
                      m();
                      d();
                    });
                } else {
                  B.css(X, z),
                    delete r.newSize,
                    B.is(":visible") ? m() : (r.size = b),
                    d();
                }
              }
            });
        }
      },
      ba = function (d, b, c) {
        d = (d ? d : "east,west,center").split(",");
        a.each(d, (d, g) => {
          if (x[g]) {
            var f = t[g],
              h = q[g],
              m = x[g],
              n = !0,
              B = {},
              v = a.layout.showInvisibly(m),
              E = {
                top: $("north", !0),
                bottom: $("south", !0),
                left: $("west", !0),
                right: $("east", !0),
                width: 0,
                height: 0,
              };
            E.width = u.innerWidth - E.left - E.right;
            E.height = u.innerHeight - E.bottom - E.top;
            E.top += u.inset.top;
            E.bottom += u.inset.bottom;
            E.left += u.inset.left;
            E.right += u.inset.right;
            a.extend(h, I(m));
            if ("center" === g) {
              if (
                !c &&
                h.isVisible &&
                E.width === h.outerWidth &&
                E.height === h.outerHeight
              ) {
                return m.css(v), !0;
              }
              a.extend(h, na(g), { maxWidth: E.width, maxHeight: E.height });
              B = E;
              h.newWidth = B.width;
              h.newHeight = B.height;
              B.width = H(m, B.width);
              B.height = w(m, B.height);
              n = 0 <= B.width && 0 <= B.height;
              if (!q.initialized && f.minWidth > E.width) {
                var f = f.minWidth - h.outerWidth,
                  E = t.east.minSize || 0,
                  y = t.west.minSize || 0,
                  A = q.east.size,
                  z = q.west.size,
                  F = A,
                  D = z;
                0 < f &&
                  q.east.isVisible &&
                  A > E &&
                  ((F = e(A - E, A - f)), (f -= A - F));
                0 < f &&
                  q.west.isVisible &&
                  z > y &&
                  ((D = e(z - y, z - f)), (f -= z - D));
                if (0 === f) {
                  A && A != E && da("east", F, !0, !0, c);
                  z && z != y && da("west", D, !0, !0, c);
                  ba("center", b, c);
                  m.css(v);
                  return;
                }
              }
            } else {
              h.isVisible && !h.noVerticalRoom && a.extend(h, I(m), na(g));
              if (!c && !h.noVerticalRoom && E.height === h.outerHeight) {
                return m.css(v), !0;
              }
              B.top = E.top;
              B.bottom = E.bottom;
              h.newSize = E.height;
              B.height = w(m, E.height);
              h.maxHeight = B.height;
              n = 0 <= h.maxHeight;
              n || (h.noVerticalRoom = !0);
            }
            n
              ? (!b && q.initialized && J("onresize_start", g),
                m.css(B),
                "center" !== g && ia(g),
                !h.noRoom || h.isClosed || h.isHidden || aa(g),
                h.isVisible && (a.extend(h, I(m)), q.initialized && ha(g)))
              : !h.noRoom && h.isVisible && aa(g);
            m.css(v);
            delete h.newSize;
            delete h.newWidth;
            delete h.newHeight;
            if (!h.isVisible) return !0;
            "center" === g &&
              ((h = L.isIE6 || !L.boxModel),
              x.north &&
                (h || "IFRAME" == q.north.tagName) &&
                x.north.css("width", H(x.north, u.innerWidth)),
              x.south &&
                (h || "IFRAME" == q.south.tagName) &&
                x.south.css("width", H(x.south, u.innerWidth)));
            !b && q.initialized && J("onresize_end", g);
          }
        });
      },
      ga = function (d) {
        D(d);
        if (v.is(":visible")) {
          if (q.initialized) {
            if (
              (!0 === d && a.isPlainObject(t.outset) && v.css(t.outset),
              a.extend(u, I(v, t.inset)),
              u.outerHeight)
            ) {
              !0 === d && Sa();
              if (!1 === J("onresizeall_start")) return !1;
              let b, c, e;
              a.each(["south", "north", "east", "west"], (a, d) => {
                x[d] &&
                  ((c = t[d]),
                  (e = q[d]),
                  e.autoResize && e.size != c.size
                    ? da(d, c.size, !0, !0, !0)
                    : (T(d), aa(d, !1, !0, !0)));
              });
              ba("", !0, !0);
              ia();
              a.each(n.allPanes, (a, d) => {
                (b = x[d]) && q[d].isVisible && J("onresize_end", d);
              });
              J("onresizeall_end");
            }
          } else pa();
        }
      },
      Ha = function (d, b) {
        let c = D.call(this, d);
        t[c].resizeChildren &&
          (b || qa(c),
          (c = V[c]),
          a.isPlainObject(c) &&
            a.each(c, (a, d) => {
              d.destroyed || d.resizeAll();
            }));
      },
      ha = function (d, b) {
        if (M()) {
          var c = D.call(this, d),
            c = c ? c.split(",") : n.allPanes;
          a.each(c, (a, d) => {
            function c(a) {
              return e(
                n.css.paddingBottom,
                parseInt(a.css("marginBottom"), 10) || 0
              );
            }
            function h() {
              var a = t[d].contentIgnoreSelector,
                a = k
                  .nextAll()
                  .not(".ui-layout-mask")
                  .not(a || ":lt(0)"),
                b = a.filter(":visible"),
                e = b.filter(":last");
              u = {
                top: k[0].offsetTop,
                height: k.outerHeight(),
                numFooters: a.length,
                hiddenFooters: a.length - b.length,
                spaceBelow: 0,
              };
              u.spaceAbove = u.top;
              u.bottom = u.top + u.height;
              u.spaceBelow = e.length
                ? e[0].offsetTop + e.outerHeight() - u.bottom + c(e)
                : c(k);
            }
            var f = x[d],
              k = S[d],
              m = t[d],
              n = q[d],
              u = n.content;
            if (!f || !k || !f.is(":visible")) return !0;
            if (!k.length && (Ba(d, !1), !k)) return;
            if (!1 !== J("onsizecontent_start", d)) {
              if (
                (!n.isMoving && !n.isResizing) ||
                m.liveContentResizing ||
                b ||
                void 0 == u.top
              ) {
                h(),
                  0 < u.hiddenFooters &&
                    "hidden" === f.css("overflow") &&
                    (f.css("overflow", "visible"),
                    h(),
                    f.css("overflow", "hidden"));
              }
              f =
                n.innerHeight -
                (u.spaceAbove - n.css.paddingTop) -
                (u.spaceBelow - n.css.paddingBottom);
              (k.is(":visible") && u.height == f) ||
                (Xa(k, f, !0), (u.height = f));
              q.initialized && J("onsizecontent_end", d);
            }
          });
        }
      },
      ia = function (d) {
        d = (d = D.call(this, d)) ? d.split(",") : n.borderPanes;
        a.each(d, (d, b) => {
          let e = t[b],
            g = q[b],
            f = x[b],
            m = K[b],
            v = R[b],
            r;
          if (f && m) {
            var B = n[b].dir,
              y = g.isClosed ? "_closed" : "_open",
              E = e[`spacing${y}`],
              A = e[`togglerAlign${y}`],
              y = e[`togglerLength${y}`],
              z;
            if (0 === E) m.hide();
            else {
              g.noRoom || g.isHidden || m.show();
              "horz" === B
                ? ((z = u.innerWidth),
                  (g.resizerLength = z),
                  (f = a.layout.cssNum(f, "left")),
                  m.css({
                    width: H(m, z),
                    height: w(m, E),
                    left: -9999 < f ? f : u.inset.left,
                  }))
                : ((z = f.outerHeight()),
                  (g.resizerLength = z),
                  m.css({
                    height: w(m, z),
                    width: H(m, E),
                    top: u.inset.top + $("north", !0),
                  }));
              Y(e, m);
              if (v) {
                if (0 === y || (g.isSliding && e.hideTogglerOnSlide)) {
                  v.hide();
                  return;
                }
                v.show();
                if (!(0 < y) || "100%" === y || y > z) (y = z), (A = 0);
                else if (c(A)) {
                  switch (A) {
                    case "top":
                    case "left":
                      A = 0;
                      break;
                    case "bottom":
                    case "right":
                      A = z - y;
                      break;
                    default:
                      A = h((z - y) / 2);
                  }
                } else (f = parseInt(A, 10)), (A = 0 <= A ? f : z - y + f);
                if ("horz" === B) {
                  const F = H(v, y);
                  v.css({ width: F, height: w(v, E), left: A, top: 0 });
                  v.children(".content").each(function () {
                    r = a(this);
                    r.css("marginLeft", h((F - r.outerWidth()) / 2));
                  });
                } else {
                  const D = w(v, y);
                  v.css({ height: D, width: H(v, E), top: A, left: 0 });
                  v.children(".content").each(function () {
                    r = a(this);
                    r.css("marginTop", h((D - r.outerHeight()) / 2));
                  });
                }
                Y(0, v);
              }
              q.initialized ||
                (!e.initHidden && !g.isHidden) ||
                (m.hide(), v && v.hide());
            }
          }
        });
      },
      Ta = function (a) {
        if (M()) {
          const b = D.call(this, a);
          a = R[b];
          const c = t[b];
          a &&
            ((c.closable = !0),
            a
              .bind(`click.${O}`, (a) => {
                a.stopPropagation();
                fa(b);
              })
              .css("visibility", "visible")
              .css("cursor", "pointer")
              .attr("title", q[b].isClosed ? c.tips.Open : c.tips.Close)
              .show());
        }
      },
      Ea = function (d, b) {
        a.layout.plugins.buttons &&
          a.each(q[d].pins, (c, e) => {
            a.layout.buttons.setPinState(F, a(e), d, b);
          });
      },
      v = a(this).eq(0);
    if (!v.length) return W(t.errors.containerMissing);
    if (v.data("layoutContainer") && v.data("layout")) return v.data("layout");
    var x = {},
      S = {},
      K = {},
      R = {},
      U = a([]),
      u = q.container,
      O = q.id,
      F = {
        options: t,
        state: q,
        container: v,
        panes: x,
        contents: S,
        resizers: K,
        togglers: R,
        hide: Ca,
        show: ua,
        toggle: fa,
        open: ja,
        close: ca,
        slideOpen: Wa,
        slideClose: Fa,
        slideToggle: function (a) {
          a = D.call(this, a);
          fa(a, !0);
        },
        setSizeLimits: T,
        _sizePane: da,
        sizePane: sa,
        sizeContent: ha,
        swapPanes: function (b, c) {
          function f(b) {
            const d = x[b],
              c = S[b];
            return d
              ? {
                  pane: b,
                  P: d ? d[0] : !1,
                  C: c ? c[0] : !1,
                  state: a.extend(!0, {}, q[b]),
                  options: a.extend(!0, {}, t[b]),
                }
              : !1;
          }
          function h(b, d) {
            if (b) {
              let c = b.P,
                g = b.C,
                f = b.pane,
                k = n[d],
                l = a.extend(!0, {}, q[d]),
                m = t[d],
                p = { resizerCursor: m.resizerCursor };
              a.each(["fxName", "fxSpeed", "fxSettings"], (a, d) => {
                p[`${d}_open`] = m[`${d}_open`];
                p[`${d}_close`] = m[`${d}_close`];
                p[`${d}_size`] = m[`${d}_size`];
              });
              x[d] = a(c)
                .data({ layoutPane: F[d], layoutEdge: d })
                .css(n.hidden)
                .css(k.cssReq);
              S[d] = g ? a(g) : !1;
              t[d] = a.extend(!0, {}, b.options, p);
              q[d] = a.extend(!0, {}, b.state);
              c.className = c.className.replace(
                new RegExp(`${m.paneClass}-${f}`, "g"),
                `${m.paneClass}-${d}`
              );
              za(d);
              k.dir != n[f].dir
                ? ((c = w[d] || 0),
                  T(d),
                  (c = e(c, q[d].minSize)),
                  sa(d, c, !0, !0))
                : K[d].css(
                    k.side,
                    u.inset[k.side] + (q[d].isVisible ? $(d) : 0)
                  );
              b.state.isVisible && !l.isVisible
                ? Da(d, !0)
                : (ra(d), ea(d, !0));
              b = null;
            }
          }
          if (M()) {
            const g = D.call(this, b);
            q[g].edge = c;
            q[c].edge = g;
            if (!1 === J("onswap_start", g) || !1 === J("onswap_start", c)) {
              (q[g].edge = g), (q[c].edge = c);
            } else {
              var m = f(g),
                v = f(c),
                w = {};
              w[g] = m ? m.state.size : 0;
              w[c] = v ? v.state.size : 0;
              x[g] = !1;
              x[c] = !1;
              q[g] = {};
              q[c] = {};
              R[g] && R[g].remove();
              R[c] && R[c].remove();
              K[g] && K[g].remove();
              K[c] && K[c].remove();
              K[g] = K[c] = R[g] = R[c] = !1;
              h(m, c);
              h(v, g);
              m = v = w = null;
              x[g] && x[g].css(n.visible);
              x[c] && x[c].css(n.visible);
              ga();
              J("onswap_end", g);
              J("onswap_end", c);
            }
          }
        },
        showMasks: la,
        hideMasks: oa,
        initContent: Ba,
        addPane: Qa,
        removePane: Aa,
        createChildren: ya,
        refreshChildren: qa,
        enableClosable: Ta,
        disableClosable: function (a, b) {
          if (M()) {
            const c = D.call(this, a),
              e = R[c];
            e &&
              ((t[c].closable = !1),
              q[c].isClosed && ja(c, !1, !0),
              e
                .unbind(`.${O}`)
                .css("visibility", b ? "hidden" : "visible")
                .css("cursor", "default")
                .attr("title", ""));
          }
        },
        enableSlidable: function (a) {
          if (M()) {
            a = D.call(this, a);
            const b = K[a];
            b &&
              b.data("draggable") &&
              ((t[a].slidable = !0), q[a].isClosed && ea(a, !0));
          }
        },
        disableSlidable: function (a) {
          if (M()) {
            a = D.call(this, a);
            const b = K[a];
            b &&
              ((t[a].slidable = !1),
              q[a].isSliding
                ? ca(a, !1, !0)
                : (ea(a, !1),
                  b.css("cursor", "default").attr("title", ""),
                  Y(null, b[0])));
          }
        },
        enableResizable: function (a) {
          if (M()) {
            a = D.call(this, a);
            const b = K[a],
              c = t[a];
            b &&
              b.data("draggable") &&
              ((c.resizable = !0),
              b.draggable("enable"),
              q[a].isClosed ||
                b.css("cursor", c.resizerCursor).attr("title", c.tips.Resize));
          }
        },
        disableResizable: function (a) {
          if (M()) {
            a = D.call(this, a);
            const b = K[a];
            b &&
              b.data("draggable") &&
              ((t[a].resizable = !1),
              b.draggable("disable").css("cursor", "default").attr("title", ""),
              Y(null, b[0]));
          }
        },
        allowOverflow: A,
        resetOverflow: z,
        destroy: function (b, c) {
          a(window).unbind(`.${O}`);
          a(document).unbind(`.${O}`);
          "object" === typeof b ? D(b) : (c = b);
          v.clearQueue()
            .removeData("layout")
            .removeData("layoutContainer")
            .removeClass(t.containerClass)
            .unbind(`.${O}`);
          U.remove();
          a.each(n.allPanes, (a, b) => {
            Aa(b, !1, !0, c);
          });
          v.data("layoutCSS") &&
            !v.data("layoutRole") &&
            v.css(v.data("layoutCSS")).removeData("layoutCSS");
          "BODY" === u.tagName &&
            (v = a("html")).data("layoutCSS") &&
            v.css(v.data("layoutCSS")).removeData("layoutCSS");
          m(F, a.layout.onDestroy);
          Oa();
          for (const e in F) e.match(/^(container|options)$/) || delete F[e];
          F.destroyed = !0;
          return F;
        },
        initPanes: M,
        resizeAll: ga,
        runCallbacks: J,
        hasParentLayout: !1,
        children: V,
        north: !1,
        south: !1,
        west: !1,
        east: !1,
        center: !1,
      };
    return "cancel" ===
      (function () {
        $a();
        const b = t,
          c = q;
        c.creatingLayout = !0;
        m(F, a.layout.onCreate);
        if (!1 === J("onload_start")) return "cancel";
        var e = v[0],
          f = a("html"),
          g = (u.tagName = e.tagName),
          h = (u.id = e.id),
          n = (u.className = e.className),
          e = t,
          w = e.name,
          r = {},
          y = v.data("parentLayout"),
          x = v.data("layoutEdge"),
          A = y && x,
          z = a.layout.cssNum,
          D;
        u.selector = v.selector.split(".slice")[0];
        u.ref =
          (e.name ? `${e.name} layout / ` : "") +
          g +
          (h ? `#${h}` : n ? `.[${n}]` : "");
        u.isBody = "BODY" === g;
        A ||
          u.isBody ||
          ((g = v.closest(`.${a.layout.defaults.panes.paneClass}`)),
          (y = g.data("parentLayout")),
          (x = g.data("layoutEdge")),
          (A = y && x));
        v.data({ layout: F, layoutContainer: O }).addClass(e.containerClass);
        g = {
          destroy: "",
          initPanes: "",
          resizeAll: "resizeAll",
          resize: "resizeAll",
        };
        for (w in g) v.bind(`layout${w.toLowerCase()}.${O}`, F[g[w] || w]);
        A && ((F.hasParentLayout = !0), y.refreshChildren(x, F));
        v.data("layoutCSS") ||
          (u.isBody
            ? (v.data(
                "layoutCSS",
                a.extend(N(v, "position,margin,padding,border"), {
                  height: v.css("height"),
                  overflow: v.css("overflow"),
                  overflowX: v.css("overflowX"),
                  overflowY: v.css("overflowY"),
                })
              ),
              f.data(
                "layoutCSS",
                a.extend(N(f, "padding"), {
                  height: "auto",
                  overflow: f.css("overflow"),
                  overflowX: f.css("overflowX"),
                  overflowY: f.css("overflowY"),
                })
              ))
            : v.data(
                "layoutCSS",
                N(
                  v,
                  "position,margin,padding,border,top,bottom,left,right,width,height,overflow,overflowX,overflowY"
                )
              ));
        try {
          r = { overflow: "hidden", overflowX: "hidden", overflowY: "hidden" };
          v.css(r);
          e.inset &&
            !a.isPlainObject(e.inset) &&
            ((D = parseInt(e.inset, 10) || 0),
            (e.inset = { top: D, bottom: D, left: D, right: D }));
          if (u.isBody) {
            e.outset
              ? a.isPlainObject(e.outset) ||
                ((D = parseInt(e.outset, 10) || 0),
                (e.outset = { top: D, bottom: D, left: D, right: D }))
              : (e.outset = {
                  top: z(f, "paddingTop"),
                  bottom: z(f, "paddingBottom"),
                  left: z(f, "paddingLeft"),
                  right: z(f, "paddingRight"),
                }),
              f
                .css(r)
                .css({ height: "100%", border: "none", padding: 0, margin: 0 }),
              L.isIE6
                ? (v.css({
                    width: "100%",
                    height: "100%",
                    border: "none",
                    padding: 0,
                    margin: 0,
                    position: "relative",
                  }),
                  e.inset || (e.inset = I(v).inset))
                : (v.css({
                    width: "auto",
                    height: "auto",
                    margin: 0,
                    position: "absolute",
                  }),
                  v.css(e.outset)),
              a.extend(u, I(v, e.inset));
          } else {
            const H = v.css("position");
            (H && H.match(/(fixed|absolute|relative)/)) ||
              v.css("position", "relative");
            v.is(":visible") &&
              (a.extend(u, I(v, e.inset)),
              1 > u.innerHeight &&
                W(e.errors.noContainerHeight.replace(/CONTAINER/, u.ref)));
          }
          z(v, "minWidth") && v.parent().css("overflowX", "auto");
          z(v, "minHeight") && v.parent().css("overflowY", "auto");
        } catch (K) {}
        Pa();
        a(window).bind(`unload.${O}`, Oa);
        m(F, a.layout.onLoad);
        b.initPanes && pa();
        delete c.creatingLayout;
        return q.initialized;
      })()
      ? null
      : F;
  };
})(jQuery);
(function (a) {
  a.layout &&
    (a.ui || (a.ui = {}),
    (a.ui.cookie = {
      acceptsCookies: Boolean(navigator.cookieEnabled),
      read: function (f) {
        var e = document.cookie,
          e = e ? e.split(";") : [],
          h,
          c;
        for (c = 0; (h = e[c]); c++) {
          if (((h = a.trim(h).split("=")), h[0] == f)) {
            return decodeURIComponent(h[1]);
          }
        }
        return null;
      },
      write: function (f, e, h) {
        let c = "",
          m = "",
          b = !1;
        h = h || {};
        let y = h.expires || null,
          A = a.type(y);
        "date" === A
          ? (m = y)
          : "string" === A && 0 < y && ((y = parseInt(y, 10)), (A = "number"));
        "number" === A &&
          ((m = new Date()),
          0 < y ? m.setDate(m.getDate() + y) : (m.setFullYear(1970), (b = !0)));
        m && (c += `;expires=${m.toUTCString()}`);
        h.path && (c += `;path=${h.path}`);
        h.domain && (c += `;domain=${h.domain}`);
        h.secure && (c += ";secure");
        document.cookie = `${f}=${b ? "" : encodeURIComponent(e)}${c}`;
      },
      clear: function (f) {
        a.ui.cookie.write(f, "", { expires: -1 });
      },
    }),
    a.cookie ||
      (a.cookie = function (f, e, h) {
        const c = a.ui.cookie;
        if (null === e) c.clear(f);
        else {
          if (void 0 === e) return c.read(f);
          c.write(f, e, h);
        }
      }),
    (a.layout.plugins.stateManagement = !0),
    (a.layout.defaults.stateManagement = {
      enabled: !1,
      autoSave: !0,
      autoLoad: !0,
      animateLoad: !0,
      includeChildren: !0,
      stateKeys:
        "north.size,south.size,east.size,west.size,north.isClosed,south.isClosed,east.isClosed,west.isClosed,north.isHidden,south.isHidden,east.isHidden,west.isHidden",
      cookie: { name: "", domain: "", path: "", expires: "", secure: !1 },
    }),
    a.layout.optionsMap.layout.push("stateManagement"),
    a.layout.config.optionRootKeys.push("stateManagement"),
    (a.layout.state = {
      saveCookie: function (f, e, h) {
        const c = f.options,
          m = c.stateManagement;
        h = a.extend(!0, {}, m.cookie, h || null);
        f = f.state.stateData = f.readState(e || m.stateKeys);
        a.ui.cookie.write(
          h.name || c.name || "Layout",
          a.layout.state.encodeJSON(f),
          h
        );
        return a.extend(!0, {}, f);
      },
      deleteCookie: function (f) {
        f = f.options;
        a.ui.cookie.clear(f.stateManagement.cookie.name || f.name || "Layout");
      },
      readCookie: function (f) {
        f = f.options;
        return (f = a.ui.cookie.read(
          f.stateManagement.cookie.name || f.name || "Layout"
        ))
          ? a.layout.state.decodeJSON(f)
          : {};
      },
      loadCookie: function (f) {
        const e = a.layout.state.readCookie(f);
        e &&
          !a.isEmptyObject(e) &&
          ((f.state.stateData = a.extend(!0, {}, e)), f.loadState(e));
        return e;
      },
      loadState: function (f, e, h) {
        if (a.isPlainObject(e) && !a.isEmptyObject(e)) {
          if (
            ((e = f.state.stateData = a.layout.transformData(e)),
            (h = a.extend(
              {
                animateLoad: !1,
                includeChildren: f.options.stateManagement.includeChildren,
              },
              h
            )),
            f.state.initialized)
          ) {
            let c = !h.animateLoad,
              m,
              b,
              y,
              A;
            a.each(a.layout.config.borderPanes, (h, w) => {
              n = e[w];
              a.isPlainObject(n) &&
                ((s = n.size),
                (m = n.initClosed),
                (b = n.initHidden),
                (ar = n.autoResize),
                (y = f.state[w]),
                (A = y.isVisible),
                ar && (y.autoResize = ar),
                A || f._sizePane(w, s, !1, !1, !1),
                !0 === b
                  ? f.hide(w, c)
                  : !0 === m
                  ? f.close(w, !1, c)
                  : !1 === m
                  ? f.open(w, !1, c)
                  : !1 === b && f.show(w, !1, c),
                A && f._sizePane(w, s, !1, !1, c));
            });
            if (h.includeChildren) {
              let z, L;
              a.each(f.children, (b, c) => {
                (z = e[b] ? e[b].children : 0) &&
                  c &&
                  a.each(c, (a, b) => {
                    L = z[a];
                    b && L && b.loadState(L);
                  });
              });
            }
          } else {
            var n = a.extend(!0, {}, e);
            a.each(a.layout.config.allPanes, (a, b) => {
              n[b] && delete n[b].children;
            });
            a.extend(!0, f.options, n);
          }
        }
      },
      readState: function (f, e) {
        "string" === a.type(e) && (e = { keys: e });
        e || (e = {});
        var h = f.options.stateManagement,
          c = e.includeChildren,
          c = void 0 !== c ? c : h.includeChildren,
          h = e.stateKeys || h.stateKeys,
          m = { isClosed: "initClosed", isHidden: "initHidden" },
          b = f.state,
          y = a.layout.config.allPanes,
          A = {},
          z,
          L,
          n,
          H,
          w,
          I;
        a.isArray(h) && (h = h.join(","));
        for (
          var h = h.replace(/__/g, ".").split(","), N = 0, Q = h.length;
          N < Q;
          N++
        ) {
          (z = h[N].split(".")),
            (L = z[0]),
            (z = z[1]),
            0 > a.inArray(L, y) ||
              ((n = b[L][z]),
              void 0 != n &&
                ("isClosed" == z && b[L].isSliding && (n = !0),
                ((A[L] || (A[L] = {}))[m[z] ? m[z] : z] = n)));
        }
        c &&
          a.each(y, (c, e) => {
            w = f.children[e];
            H = b.stateData[e];
            a.isPlainObject(w) &&
              !a.isEmptyObject(w) &&
              ((I = A[e] || (A[e] = {})),
              I.children || (I.children = {}),
              a.each(w, (b, c) => {
                c.state.initialized
                  ? (I.children[b] = a.layout.state.readState(c))
                  : H &&
                    H.children &&
                    H.children[b] &&
                    (I.children[b] = a.extend(!0, {}, H.children[b]));
              }));
          });
        return A;
      },
      encodeJSON: function (f) {
        function e(e) {
          let c = [],
            f = 0,
            b,
            y,
            A,
            z = a.isArray(e);
          for (b in e) {
            (y = e[b]),
              (A = typeof y),
              "string" == A ? (y = `"${y}"`) : "object" == A && (y = parse(y)),
              (c[f++] = (z ? "" : `"${b}":`) + y);
          }
          return (z ? "[" : "{") + c.join(",") + (z ? "]" : "}");
        }
        return ((window.JSON || {}).stringify || e)(f);
      },
      decodeJSON: function (f) {
        try {
          return a.parseJSON ? a.parseJSON(f) : window.eval(`(${f})`) || {};
        } catch (e) {
          return {};
        }
      },
      _create: function (f) {
        const e = a.layout.state,
          h = f.options.stateManagement;
        a.extend(f, {
          readCookie: function () {
            return e.readCookie(f);
          },
          deleteCookie: function () {
            e.deleteCookie(f);
          },
          saveCookie: function (a, c) {
            return e.saveCookie(f, a, c);
          },
          loadCookie: function () {
            return e.loadCookie(f);
          },
          loadState: function (a, c) {
            e.loadState(f, a, c);
          },
          readState: function (a) {
            return e.readState(f, a);
          },
          encodeJSON: e.encodeJSON,
          decodeJSON: e.decodeJSON,
        });
        f.state.stateData = {};
        if (h.autoLoad) {
          if (a.isPlainObject(h.autoLoad)) {
            a.isEmptyObject(h.autoLoad) || f.loadState(h.autoLoad);
          } else if (h.enabled) {
            if (a.isFunction(h.autoLoad)) {
              let c = {};
              try {
                c = h.autoLoad(f, f.state, f.options, f.options.name || "");
              } catch (m) {}
              c && a.isPlainObject(c) && !a.isEmptyObject(c) && f.loadState(c);
            } else f.loadCookie();
          }
        }
      },
      _unload: function (f) {
        const e = f.options.stateManagement;
        if (e.enabled && e.autoSave) {
          if (a.isFunction(e.autoSave)) {
            try {
              e.autoSave(f, f.state, f.options, f.options.name || "");
            } catch (h) {}
          } else f.saveCookie();
        }
      },
    }),
    a.layout.onCreate.push(a.layout.state._create),
    a.layout.onUnload.push(a.layout.state._unload));
})(jQuery);
(function (a) {
  if (a.layout) {
    a.layout.plugins.buttons = !0;
    a.layout.defaults.autoBindCustomButtons = !1;
    a.layout.optionsMap.layout.push("autoBindCustomButtons");
    const f = a.layout.language;
    a.layout.buttons = {
      config: { borderPanes: "north,south,west,east" },
      init: function (e) {
        let f = e.options.name || "",
          c;
        a.each(
          "toggle open close pin toggle-slide open-slide".split(" "),
          (m, b) => {
            a.each(a.layout.buttons.config.borderPanes.split(","), (m, A) => {
              a(`.ui-layout-button-${b}-${A}`).each(function () {
                c = a(this).data("layoutName") || a(this).attr("layoutName");
                (void 0 != c && c !== f) || e.bindButton(this, b, A);
              });
            });
          }
        );
      },
      get: function (e, h, c, m) {
        let b = a(h);
        e = e.options;
        const y = e.showErrorMessages;
        b.length
          ? -1 === a.layout.buttons.config.borderPanes.indexOf(c)
            ? (y && alert(`${f.errButton + f.pane}: ${c}`), (b = a("")))
            : ((h = `${e[c].buttonClass}-${m}`),
              b.addClass(`${h} ${h}-${c}`).data("layoutName", e.name))
          : y && alert(`${f.errButton + f.selector}: ${h}`);
        return b;
      },
      bind: function (e, f, c, m) {
        const b = a.layout.buttons;
        switch (c.toLowerCase()) {
          case "toggle":
            b.addToggle(e, f, m);
            break;
          case "open":
            b.addOpen(e, f, m);
            break;
          case "close":
            b.addClose(e, f, m);
            break;
          case "pin":
            b.addPin(e, f, m);
            break;
          case "toggle-slide":
            b.addToggle(e, f, m, !0);
            break;
          case "open-slide":
            b.addOpen(e, f, m, !0);
        }
        return e;
      },
      addToggle: function (e, f, c, m) {
        a.layout.buttons.get(e, f, c, "toggle").click((a) => {
          e.toggle(c, Boolean(m));
          a.stopPropagation();
        });
        return e;
      },
      addOpen: function (e, h, c, m) {
        a.layout.buttons
          .get(e, h, c, "open")
          .attr("title", f.Open)
          .click((a) => {
            e.open(c, Boolean(m));
            a.stopPropagation();
          });
        return e;
      },
      addClose: function (e, h, c) {
        a.layout.buttons
          .get(e, h, c, "close")
          .attr("title", f.Close)
          .click((a) => {
            e.close(c);
            a.stopPropagation();
          });
        return e;
      },
      addPin: function (e, f, c) {
        const m = a.layout.buttons.get(e, f, c, "pin");
        if (m.length) {
          const b = e.state[c];
          m.click(function (f) {
            a.layout.buttons.setPinState(
              e,
              a(this),
              c,
              b.isSliding || b.isClosed
            );
            b.isSliding || b.isClosed ? e.open(c) : e.close(c);
            f.stopPropagation();
          });
          a.layout.buttons.setPinState(e, m, c, !b.isClosed && !b.isSliding);
          b.pins.push(f);
        }
        return e;
      },
      setPinState: function (a, h, c, m) {
        let b = h.attr("pin");
        (b && m === ("down" == b)) ||
          ((a = `${a.options[c].buttonClass}-pin`),
          (b = `${a}-${c}`),
          (c = `${a}-up ${b}-up`),
          (a = `${a}-down ${b}-down`),
          h
            .attr("pin", m ? "down" : "up")
            .attr("title", m ? f.Unpin : f.Pin)
            .removeClass(m ? c : a)
            .addClass(m ? a : c));
      },
      syncPinBtns: function (e, f, c) {
        a.each(state[f].pins, (m, b) => {
          a.layout.buttons.setPinState(e, a(b), f, c);
        });
      },
      _load: function (e) {
        a.extend(e, {
          bindButton: function (c, f, b) {
            return a.layout.buttons.bind(e, c, f, b);
          },
          addToggleBtn: function (c, f, b) {
            return a.layout.buttons.addToggle(e, c, f, b);
          },
          addOpenBtn: function (c, f, b) {
            return a.layout.buttons.addOpen(e, c, f, b);
          },
          addCloseBtn: function (c, f) {
            return a.layout.buttons.addClose(e, c, f);
          },
          addPinBtn: function (c, f) {
            return a.layout.buttons.addPin(e, c, f);
          },
        });
        for (let f = 0; 4 > f; f++) {
          e.state[a.layout.buttons.config.borderPanes[f]].pins = [];
        }
        e.options.autoBindCustomButtons && a.layout.buttons.init(e);
      },
      _unload: function (a) {},
    };
    a.layout.onLoad.push(a.layout.buttons._load);
  }
})(jQuery);
(function (a) {
  a.layout.plugins.browserZoom = !0;
  a.layout.defaults.browserZoomCheckInterval = 1e3;
  a.layout.optionsMap.layout.push("browserZoomCheckInterval");
  a.layout.browserZoom = {
    _init: function (f) {
      !1 !== a.layout.browserZoom.ratio() && a.layout.browserZoom._setTimer(f);
    },
    _setTimer: function (f) {
      if (!f.destroyed) {
        const e = f.options,
          h = f.state,
          c = f.hasParentLayout
            ? 5e3
            : Math.max(e.browserZoomCheckInterval, 100);
        setTimeout(() => {
          if (!f.destroyed && e.resizeWithWindow) {
            const c = a.layout.browserZoom.ratio();
            c !== h.browserZoom && ((h.browserZoom = c), f.resizeAll());
            a.layout.browserZoom._setTimer(f);
          }
        }, c);
      }
    },
    ratio: function () {
      function f(a, b) {
        return ((parseInt(a, 10) / parseInt(b, 10)) * 100).toFixed();
      }
      let e = window,
        h = screen,
        c = document,
        m = c.documentElement || c.body,
        b = a.layout.browser,
        y = b.version,
        A,
        z,
        L;
      return !b.msie || 8 < y
        ? !1
        : h.deviceXDPI && h.systemXDPI
        ? f(h.deviceXDPI, h.systemXDPI)
        : b.webkit && (A = c.body.getBoundingClientRect)
        ? f(A.left - A.right, c.body.offsetWidth)
        : b.webkit && (z = e.outerWidth)
        ? f(z, e.innerWidth)
        : (z = h.width) && (L = m.clientWidth)
        ? f(z, L)
        : !1;
    },
  };
  a.layout.onReady.push(a.layout.browserZoom._init);
})(jQuery);
(function (a) {
  a.effects &&
    ((a.layout.defaults.panes.useOffscreenClose = !1),
    a.layout.plugins && (a.layout.plugins.effects.slideOffscreen = !0),
    (a.layout.effects.slideOffscreen = a.extend(
      !0,
      {},
      a.layout.effects.slide
    )),
    (a.effects.slideOffscreen = function (f) {
      return this.queue(function () {
        var e = a.effects,
          h = f.options,
          c = a(this),
          m = c.data("layoutEdge"),
          b = c.data("parentLayout").state,
          m = b[m].size,
          y = this.style,
          A = "show" == e.setMode(c, h.mode || "show"),
          e = h.direction || "left",
          z = "up" == e || "down" == e ? "top" : "left",
          L = "up" == e || "left" == e,
          n = a.layout.config.offscreenCSS || {},
          H = a.layout.config.offscreenReset,
          w = {};
        w[z] = (A ? (L ? "+=" : "-=") : L ? "-=" : "+=") + m;
        A
          ? (c.data("offscreenResetTop", { top: y.top, bottom: y.bottom }),
            L
              ? c.css(z, isNaN(m) ? `-${m}` : -m)
              : "right" === e
              ? c.css({ left: b.container.layoutWidth, right: "auto" })
              : c.css({ top: b.container.layoutHeight, bottom: "auto" }),
            "top" === z && c.css(c.data(H) || {}))
          : (c.data("offscreenResetTop", { top: y.top, bottom: y.bottom }),
            c.data(H, { left: y.left, right: y.right }));
        c.show().animate(w, {
          queue: !1,
          duration: f.duration,
          easing: h.easing,
          complete: function () {
            c.data("offscreenResetTop") &&
              c
                .css(c.data("offscreenResetTop"))
                .removeData("offscreenResetTop");
            A ? c.css(c.data(H) || {}).removeData(H) : c.css(n);
            f.callback && f.callback.apply(this, arguments);
            c.dequeue();
          },
        });
      });
    }));
})(jQuery);
